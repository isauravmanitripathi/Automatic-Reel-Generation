================================================================================
PYTHON FILES EXTRACTION
Root Folder: /Volumes/hard-drive/better-reel-gen
Total Files: 18
================================================================================


================================================================================
FILE: config.py
================================================================================

"""
Configuration constants for Better Reel Generator
"""
import os
from pathlib import Path

# ============================================================================
# PROJECT PATHS
# ============================================================================
PROJECT_ROOT = Path(__file__).parent
DOWNLOADS_DIR = PROJECT_ROOT / "downloads"
NORMALIZED_DIR = PROJECT_ROOT / "normalized"
TEMP_DIR = PROJECT_ROOT / "temp"
OUTPUTS_DIR = PROJECT_ROOT / "outputs"

# Create directories if they don't exist
for directory in [DOWNLOADS_DIR, NORMALIZED_DIR, TEMP_DIR, OUTPUTS_DIR]:
    directory.mkdir(parents=True, exist_ok=True)

# ============================================================================
# VIDEO SETTINGS
# ============================================================================
# Target resolutions for different platforms
RESOLUTIONS = {
    'reels': (1080, 1920),      # Instagram Reels / TikTok (9:16)
    'shorts': (1080, 1920),     # YouTube Shorts (9:16)
    'story': (1080, 1920),      # Instagram Story (9:16)
    'landscape': (1920, 1080),  # YouTube (16:9)
    'square': (1080, 1080),     # Instagram Square (1:1)
}

# Video encoding settings
VIDEO_CODEC = 'libx264'
VIDEO_PRESET = 'medium'  # ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow
VIDEO_CRF = 23  # Constant Rate Factor (0-51, lower = better quality, 18-28 recommended)
TARGET_FPS = 30
TARGET_BITRATE = '5M'

# Audio encoding settings
AUDIO_CODEC = 'aac'
AUDIO_BITRATE = '192k'
AUDIO_SAMPLE_RATE = 48000

# ============================================================================
# DOWNLOAD SETTINGS
# ============================================================================
# yt-dlp settings
YTDLP_FORMAT = 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best'
YTDLP_AUDIO_FORMAT = 'bestaudio[ext=m4a]/bestaudio'

# gallery-dl settings (for Instagram/Pinterest)
GALLERY_DL_CONFIG = {
    'extractor': {
        'instagram': {
            'videos': True,
            'video-reels': True
        },
        'pinterest': {
            'videos': True
        }
    }
}

# Maximum concurrent downloads
MAX_CONCURRENT_DOWNLOADS = 3

# ============================================================================
# AUDIO ANALYSIS SETTINGS
# ============================================================================
# Beat detection
BEAT_TRACK_UNITS = 'time'  # 'time' or 'frames'
BEAT_HOP_LENGTH = 512
BEAT_START_BPM = 120

# Vocal detection
VOCAL_THRESHOLD = 0.5  # Lower = more sensitive
VOCAL_MIN_CHANGES = 5

# ============================================================================
# VIDEO CUTTING SETTINGS
# ============================================================================
# Cutting modes
CUT_MODES = {
    'beats': 'Beat Detection',
    'vocals': 'Vocal Changes',
    'hybrid': 'Beats + Vocals'
}

# Segment ordering
ORDER_MODES = {
    'sequential': 'Sequential (in order)',
    'random': 'Random (shuffled)'
}

# Minimum and maximum segment duration (seconds)
MIN_SEGMENT_DURATION = 0.3
MAX_SEGMENT_DURATION = 5.0

# ============================================================================
# IMAGE OVERLAY SETTINGS
# ============================================================================
# Animation types available
IMAGE_OVERLAY_ANIMATIONS = [
    'slide_bottom',
    'slide_left', 
    'slide_right',
    'slide_top',
    'fade',
    'random'
]

# Image sizing
IMAGE_OVERLAY_PADDING = 0.15  # 15% padding from edges (85% max size)
IMAGE_MAX_SIZE_RATIO = 0.85  # Max 85% of frame size (15% padding from boundaries)

# Animation settings
IMAGE_ANIMATION_DURATION = 0.3  # Quick animations (0.3 seconds)
IMAGE_FADE_IN_DURATION = 0.2  # Fade in duration
IMAGE_FADE_OUT_DURATION = 0.2  # Fade out duration

# Default timing
IMAGE_DEFAULT_DELAY = 0.0  # No delay between images by default

# ============================================================================
# FFMPEG SETTINGS
# ============================================================================
FFMPEG_THREADS = os.cpu_count() or 4
FFMPEG_LOGLEVEL = 'error'  # quiet, panic, fatal, error, warning, info, verbose, debug

# Normalization filters
NORMALIZE_FILTERS = {
    'denoise': 'hqdn3d=1.5:1.5:6:6',
    'stabilize': 'deshake',
    'sharpen': 'unsharp=5:5:1.0:5:5:0.0',
}

# ============================================================================
# FILE MANAGEMENT
# ============================================================================
# Supported file extensions
VIDEO_EXTENSIONS = ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.flv']
AUDIO_EXTENSIONS = ['.mp3', '.wav', '.m4a', '.aac', '.flac', '.ogg']
IMAGE_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.webp', '.gif']

# Maximum file size for processing (in MB)
MAX_FILE_SIZE_MB = 1000

# Auto-cleanup temp files after processing
AUTO_CLEANUP = True
CLEANUP_AFTER_DAYS = 7

# ============================================================================
# URL PATTERNS
# ============================================================================
URL_PATTERNS = {
    'youtube': [
        r'youtube\.com/watch',
        r'youtube\.com/shorts',
        r'youtu\.be/',
        r'youtube\.com/embed'
    ],
    'instagram': [
        r'instagram\.com/reel',
        r'instagram\.com/p/',
        r'instagram\.com/tv'
    ],
    'pinterest': [
        r'pinterest\.com/pin',
        r'pin\.it/'
    ]
}

# ============================================================================
# CLI SETTINGS
# ============================================================================
# Rich console theme
CONSOLE_THEME = {
    'success': 'green',
    'error': 'red',
    'warning': 'yellow',
    'info': 'cyan',
    'progress': 'magenta'
}

# Progress bar style
PROGRESS_BAR_STYLE = 'bar.complete'

# ============================================================================
# VALIDATION RULES
# ============================================================================
# Minimum video duration (seconds)
MIN_VIDEO_DURATION = 1.0

# Maximum number of URLs to process at once
MAX_URLS_PER_BATCH = 20

# Maximum total video duration for combining (seconds)
MAX_COMBINED_DURATION = 300  # 5 minutes

# ============================================================================
# ERROR MESSAGES
# ============================================================================
ERROR_MESSAGES = {
    'invalid_url': '❌ Invalid URL provided',
    'download_failed': '❌ Download failed',
    'no_videos': '❌ No videos found',
    'normalization_failed': '❌ Video normalization failed',
    'combine_failed': '❌ Failed to combine videos',
    'audio_analysis_failed': '❌ Audio analysis failed',
    'cutting_failed': '❌ Video cutting failed',
    'invalid_audio': '❌ Invalid audio file',
    'ffmpeg_not_found': '❌ FFmpeg not found. Please install FFmpeg.',
    'no_images': '❌ No images found in folder',
    'invalid_image_folder': '❌ Invalid images folder',
    'overlay_failed': '❌ Image overlay failed',
}

SUCCESS_MESSAGES = {
    'download_complete': '✅ Download complete',
    'normalization_complete': '✅ Normalization complete',
    'combine_complete': '✅ Videos combined successfully',
    'audio_analysis_complete': '✅ Audio analysis complete',
    'cutting_complete': '✅ Video cutting complete',
    'generation_complete': '✅ Video generation complete',
    'overlay_complete': '✅ Image overlay complete',
}

# ============================================================================
# DEBUG MODE
# ============================================================================
DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'
VERBOSE = os.getenv('VERBOSE', 'False').lower() == 'true'

# ============================================================================
# VERSION
# ============================================================================
VERSION = '1.0.0'
APP_NAME = 'Better Reel Generator'


================================================================================
FILE: download-youtube.py
================================================================================

#!/usr/bin/env python3
"""
YouTube Downloader with yt-dlp
Downloads best quality video/audio and re-encodes for Mac compatibility
"""

import subprocess
import sys
import os
import shutil


def check_dependencies():
    """Check if yt-dlp and ffmpeg are installed"""
    dependencies = {
        'yt-dlp': 'yt-dlp',
        'ffmpeg': 'ffmpeg'
    }
    
    missing = []
    for name, command in dependencies.items():
        # Use shutil.which() to find the command in PATH
        # This works even in virtual environments
        if shutil.which(command):
            print(f"✓ {name} is installed")
        else:
            missing.append(name)
            print(f"✗ {name} is NOT installed")
    
    if missing:
        print("\nPlease install missing dependencies:")
        for dep in missing:
            if dep == 'yt-dlp':
                print("  pip install yt-dlp")
            elif dep == 'ffmpeg':
                print("  brew install ffmpeg  (on Mac)")
        sys.exit(1)


def get_url():
    """Get URL from user"""
    while True:
        url = input("\nEnter the video URL: ").strip()
        if url:
            return url
        print("Please enter a valid URL")


def get_download_type():
    """Ask user whether to download audio or video"""
    while True:
        print("\nWhat would you like to download?")
        print("1. Video (MP4)")
        print("2. Audio (MP3)")
        choice = input("Enter your choice (1 or 2): ").strip()
        
        if choice == '1':
            return 'video'
        elif choice == '2':
            return 'audio'
        else:
            print("Invalid choice. Please enter 1 or 2.")


def check_video_availability(url):
    """Check if video is available and get info"""
    print("\n🔍 Checking video availability...")
    
    command = [
        'yt-dlp',
        '--dump-json',
        '--no-warnings',
        url
    ]
    
    try:
        result = subprocess.run(command, capture_output=True, text=True, check=True)
        print("✓ Video is available")
        return True
    except subprocess.CalledProcessError as e:
        print(f"\n❌ Cannot access this video. Possible reasons:")
        print("   • Video is age-restricted")
        print("   • Video is private or deleted")
        print("   • Video is geo-blocked in your region")
        print("   • Invalid URL")
        print("\nTry:")
        print("   • Using a different video URL")
        print("   • Checking if you can watch it in your browser")
        return False


def download_video(url, output_dir='downloads'):
    """Download video in best quality and re-encode to MP4"""
    print("\n🎬 Downloading video...")
    
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # yt-dlp options for video with multiple fallback formats
    command = [
        'yt-dlp',
        # Try best quality first, with multiple fallbacks
        '--format', 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo+bestaudio/best',
        '--merge-output-format', 'mp4',
        '--output', f'{output_dir}/%(title)s.%(ext)s',
        # Re-encode to ensure Mac compatibility
        '--postprocessor-args', 'ffmpeg:-c:v libx264 -c:a aac -movflags +faststart',
        '--progress',
        '--no-warnings',
        # Add cookies if needed for age-restricted content
        '--cookies-from-browser', 'chrome',  # Try to use Chrome cookies
        url
    ]
    
    try:
        subprocess.run(command, check=True)
        print("\n✅ Video downloaded successfully!")
        print(f"📁 Location: {output_dir}/")
        return True
    except subprocess.CalledProcessError as e:
        # Try without cookies as fallback
        print("\n⚠️  First attempt failed, trying alternative method...")
        
        command_no_cookies = [
            'yt-dlp',
            '--format', 'best',  # Simple fallback
            '--merge-output-format', 'mp4',
            '--output', f'{output_dir}/%(title)s.%(ext)s',
            '--postprocessor-args', 'ffmpeg:-c:v libx264 -c:a aac -movflags +faststart',
            '--progress',
            '--no-warnings',
            url
        ]
        
        try:
            subprocess.run(command_no_cookies, check=True)
            print("\n✅ Video downloaded successfully!")
            print(f"📁 Location: {output_dir}/")
            return True
        except subprocess.CalledProcessError:
            print(f"\n❌ Error downloading video")
            print("This video cannot be downloaded. Please try a different video.")
            return False


def download_audio(url, output_dir='downloads'):
    """Download audio and convert to MP3"""
    print("\n🎵 Downloading audio...")
    
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # yt-dlp options for audio
    command = [
        'yt-dlp',
        '--extract-audio',
        '--audio-format', 'mp3',
        '--audio-quality', '0',  # Best quality
        '--output', f'{output_dir}/%(title)s.%(ext)s',
        '--postprocessor-args', 'ffmpeg:-ar 48000 -b:a 320k',
        '--progress',
        '--no-warnings',
        '--cookies-from-browser', 'chrome',
        url
    ]
    
    try:
        subprocess.run(command, check=True)
        print("\n✅ Audio downloaded successfully!")
        print(f"📁 Location: {output_dir}/")
        return True
    except subprocess.CalledProcessError:
        # Try without cookies
        print("\n⚠️  First attempt failed, trying alternative method...")
        
        command_no_cookies = [
            'yt-dlp',
            '--extract-audio',
            '--audio-format', 'mp3',
            '--audio-quality', '0',
            '--output', f'{output_dir}/%(title)s.%(ext)s',
            '--postprocessor-args', 'ffmpeg:-ar 48000 -b:a 320k',
            '--progress',
            '--no-warnings',
            url
        ]
        
        try:
            subprocess.run(command_no_cookies, check=True)
            print("\n✅ Audio downloaded successfully!")
            print(f"📁 Location: {output_dir}/")
            return True
        except subprocess.CalledProcessError:
            print(f"\n❌ Error downloading audio")
            print("This video cannot be downloaded. Please try a different video.")
            return False


def main():
    """Main function"""
    print("=" * 50)
    print("YouTube Downloader with yt-dlp")
    print("=" * 50)
    
    # Check dependencies
    check_dependencies()
    
    # Get user input
    url = get_url()
    
    # Check if video is available
    if not check_video_availability(url):
        sys.exit(1)
    
    download_type = get_download_type()
    
    # Download based on user choice
    success = False
    if download_type == 'video':
        success = download_video(url)
    else:
        success = download_audio(url)
    
    if success:
        print("\n✨ Done!")
    else:
        print("\n⚠️  Download failed. Please try a different video.")
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n👋 Download cancelled by user")
        sys.exit(0)


================================================================================
FILE: downloaders/__init__.py
================================================================================

"""
Downloaders module for Better Reel Generator
Handles downloading from YouTube, Instagram, and Pinterest
"""

from .youtube import download as download_youtube
from .instagram import download as download_instagram
from .pinterest import download as download_pinterest

__all__ = [
    'download_youtube',
    'download_instagram',
    'download_pinterest',
]

# Version
__version__ = '1.0.0'


================================================================================
FILE: downloaders/instagram.py
================================================================================

"""
Instagram downloader using gallery-dl
Supports Instagram Reels, Posts, and IGTV
"""

import os
import subprocess
import json
import shutil
from pathlib import Path
from typing import Dict, Optional, List

import config


class InstagramDownloader:
    """Handler for Instagram downloads using gallery-dl"""
    
    def __init__(self, output_dir: Optional[Path] = None):
        """
        Initialize Instagram downloader
        
        Args:
            output_dir: Directory to save downloads (default: config.DOWNLOADS_DIR)
        """
        self.output_dir = output_dir or config.DOWNLOADS_DIR
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def download_reel(self, url: str, cookies_file: Optional[str] = None) -> Optional[Dict]:
        """
        Download Instagram Reel
        
        Args:
            url: Instagram reel URL
            cookies_file: Optional cookies file for authentication
            
        Returns:
            Dict with download info or None if failed
        """
        try:
            # Create a specific subdirectory for this download
            download_id = self._extract_id_from_url(url)
            download_dir = self.output_dir / f"instagram_{download_id}"
            download_dir.mkdir(parents=True, exist_ok=True)
            
            # Build gallery-dl command
            cmd = [
                'gallery-dl',
                '--write-metadata',
                '-d', str(download_dir),
            ]
            
            # Add cookies if provided
            if cookies_file and os.path.exists(cookies_file):
                cmd.extend(['--cookies', cookies_file])
            
            cmd.append(url)
            
            # Execute download
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=False
            )
            
            if result.returncode != 0:
                if config.DEBUG:
                    print(f"gallery-dl error: {result.stderr}")
                return None
            
            # Find downloaded video file
            video_files = self._find_video_files(download_dir)
            
            if not video_files:
                return None
            
            video_path = video_files[0]  # Use first video found
            
            # Try to load metadata
            metadata = self._load_metadata(download_dir)
            
            return {
                'video_path': str(video_path),
                'title': metadata.get('description', '')[:100] if metadata else 'Instagram Reel',
                'url': url,
                'id': download_id,
                'metadata': metadata,
            }
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error downloading Instagram reel: {str(e)}")
            return None
    
    def download_post(self, url: str, cookies_file: Optional[str] = None) -> Optional[Dict]:
        """
        Download Instagram Post (may contain multiple videos/images)
        
        Args:
            url: Instagram post URL
            cookies_file: Optional cookies file
            
        Returns:
            Dict with download info
        """
        # Same logic as download_reel, gallery-dl handles both
        return self.download_reel(url, cookies_file)
    
    def download_profile_reels(self, profile_url: str, max_count: int = 50, 
                               cookies_file: Optional[str] = None) -> List[Dict]:
        """
        Download multiple reels from a profile
        
        Args:
            profile_url: Instagram profile URL
            max_count: Maximum number of reels to download
            cookies_file: Optional cookies file
            
        Returns:
            List of download results
        """
        try:
            download_dir = self.output_dir / "instagram_profile"
            download_dir.mkdir(parents=True, exist_ok=True)
            
            # Build command
            cmd = [
                'gallery-dl',
                '--write-metadata',
                '-d', str(download_dir),
                '--range', f'1-{max_count}',
            ]
            
            if cookies_file and os.path.exists(cookies_file):
                cmd.extend(['--cookies', cookies_file])
            
            cmd.append(profile_url)
            
            # Execute
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=False
            )
            
            if result.returncode != 0:
                return []
            
            # Find all downloaded videos
            video_files = self._find_video_files(download_dir)
            
            results = []
            for video_path in video_files:
                results.append({
                    'video_path': str(video_path),
                    'title': f'Instagram Reel {len(results) + 1}',
                    'url': profile_url,
                })
            
            return results
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error downloading profile reels: {str(e)}")
            return []
    
    def _extract_id_from_url(self, url: str) -> str:
        """Extract ID from Instagram URL"""
        # Instagram URLs: /p/CODE/, /reel/CODE/, /tv/CODE/
        parts = url.rstrip('/').split('/')
        for i, part in enumerate(parts):
            if part in ['p', 'reel', 'tv'] and i + 1 < len(parts):
                return parts[i + 1]
        
        # Fallback: use hash of URL
        return str(hash(url))[:10]
    
    def _find_video_files(self, directory: Path) -> List[Path]:
        """Find all video files in directory"""
        video_files = []
        
        for ext in config.VIDEO_EXTENSIONS:
            video_files.extend(directory.rglob(f'*{ext}'))
        
        # Sort by modification time (newest first)
        video_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
        
        return video_files
    
    def _load_metadata(self, directory: Path) -> Optional[Dict]:
        """Load metadata JSON file if exists"""
        json_files = list(directory.rglob('*.json'))
        
        if not json_files:
            return None
        
        try:
            with open(json_files[0], 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception:
            return None


def download(url: str, cookies_file: Optional[str] = None, output_dir: Optional[Path] = None) -> Optional[Dict]:
    """
    Main download function for Instagram
    
    Args:
        url: Instagram URL (reel/post/profile)
        cookies_file: Optional cookies file for authentication
        output_dir: Custom output directory
        
    Returns:
        Dict with download results or None if failed
    """
    downloader = InstagramDownloader(output_dir)
    
    # Detect URL type
    if '/reel/' in url or '/p/' in url or '/tv/' in url:
        return downloader.download_reel(url, cookies_file)
    else:
        # Assume profile URL
        results = downloader.download_profile_reels(url, max_count=10, cookies_file=cookies_file)
        return results[0] if results else None


def check_gallery_dl_installed() -> bool:
    """
    Check if gallery-dl is installed
    
    Returns:
        True if installed, False otherwise
    """
    try:
        subprocess.run(['gallery-dl', '--version'], 
                      capture_output=True, 
                      check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


================================================================================
FILE: downloaders/pinterest.py
================================================================================

"""
Pinterest downloader using gallery-dl
Supports Pinterest pins and boards
"""

import os
import subprocess
import json
from pathlib import Path
from typing import Dict, Optional, List
from urllib.parse import urlparse, parse_qs

import config


class PinterestDownloader:
    """Handler for Pinterest downloads using gallery-dl"""
    
    def __init__(self, output_dir: Optional[Path] = None):
        """
        Initialize Pinterest downloader
        
        Args:
            output_dir: Directory to save downloads (default: config.DOWNLOADS_DIR)
        """
        self.output_dir = output_dir or config.DOWNLOADS_DIR
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def download_pin(self, url: str) -> Optional[Dict]:
        """
        Download single Pinterest pin
        
        Args:
            url: Pinterest pin URL
            
        Returns:
            Dict with download info or None if failed
        """
        try:
            # Create subdirectory for this pin
            pin_id = self._extract_pin_id(url)
            download_dir = self.output_dir / f"pinterest_{pin_id}"
            download_dir.mkdir(parents=True, exist_ok=True)
            
            # Build gallery-dl command
            cmd = [
                'gallery-dl',
                '--write-metadata',
                '-d', str(download_dir),
                url
            ]
            
            # Execute
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=False
            )
            
            if result.returncode != 0:
                if config.DEBUG:
                    print(f"gallery-dl error: {result.stderr}")
                return None
            
            # Find downloaded video
            video_files = self._find_video_files(download_dir)
            
            if not video_files:
                return None
            
            video_path = video_files[0]
            
            # Load metadata if available
            metadata = self._load_metadata(download_dir)
            
            return {
                'video_path': str(video_path),
                'title': metadata.get('description', 'Pinterest Video')[:100] if metadata else 'Pinterest Video',
                'url': url,
                'id': pin_id,
                'metadata': metadata,
            }
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error downloading Pinterest pin: {str(e)}")
            return None
    
    def download_board(self, url: str, max_count: int = 50) -> List[Dict]:
        """
        Download videos from Pinterest board
        
        Args:
            url: Pinterest board URL
            max_count: Maximum number of videos to download
            
        Returns:
            List of download results
        """
        try:
            download_dir = self.output_dir / "pinterest_board"
            download_dir.mkdir(parents=True, exist_ok=True)
            
            # Build command
            cmd = [
                'gallery-dl',
                '--write-metadata',
                '-d', str(download_dir),
                '--range', f'1-{max_count}',
                url
            ]
            
            # Execute
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=False
            )
            
            if result.returncode != 0:
                return []
            
            # Find all videos
            video_files = self._find_video_files(download_dir)
            
            results = []
            for video_path in video_files:
                results.append({
                    'video_path': str(video_path),
                    'title': f'Pinterest Video {len(results) + 1}',
                    'url': url,
                })
            
            return results
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error downloading Pinterest board: {str(e)}")
            return []
    
    def download_search(self, search_url: str, max_count: int = 50) -> List[Dict]:
        """
        Download videos from Pinterest search results
        
        Args:
            search_url: Pinterest search URL
            max_count: Maximum number of videos to download
            
        Returns:
            List of download results
        """
        try:
            # Extract search term
            search_term = self._extract_search_term(search_url)
            
            download_dir = self.output_dir / f"pinterest_search_{search_term}"
            download_dir.mkdir(parents=True, exist_ok=True)
            
            # Build command
            cmd = [
                'gallery-dl',
                '--write-metadata',
                '-d', str(download_dir),
                '--range', f'1-{max_count}',
                search_url
            ]
            
            # Execute
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=False
            )
            
            if result.returncode != 0:
                return []
            
            # Find all videos
            video_files = self._find_video_files(download_dir)
            
            results = []
            for video_path in video_files:
                results.append({
                    'video_path': str(video_path),
                    'title': f'{search_term} - {len(results) + 1}',
                    'url': search_url,
                })
            
            return results
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error downloading Pinterest search: {str(e)}")
            return []
    
    def _extract_pin_id(self, url: str) -> str:
        """Extract pin ID from URL"""
        # Pinterest URLs: /pin/PIN_ID/
        parts = url.rstrip('/').split('/')
        
        for i, part in enumerate(parts):
            if part == 'pin' and i + 1 < len(parts):
                return parts[i + 1]
        
        # Fallback
        return str(hash(url))[:10]
    
    def _extract_search_term(self, url: str) -> str:
        """Extract search term from Pinterest search URL"""
        try:
            parsed = urlparse(url)
            query_params = parse_qs(parsed.query)
            
            # Pinterest uses 'q' parameter for search
            search_term = query_params.get('q', ['unknown'])[0]
            return search_term.replace(' ', '_')
        except Exception:
            return 'pinterest_search'
    
    def _find_video_files(self, directory: Path) -> List[Path]:
        """Find all video files in directory"""
        video_files = []
        
        for ext in config.VIDEO_EXTENSIONS:
            video_files.extend(directory.rglob(f'*{ext}'))
        
        # Sort by modification time
        video_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
        
        return video_files
    
    def _load_metadata(self, directory: Path) -> Optional[Dict]:
        """Load metadata JSON file if exists"""
        json_files = list(directory.rglob('*.json'))
        
        if not json_files:
            return None
        
        try:
            with open(json_files[0], 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception:
            return None


def download(url: str, max_count: int = 50, output_dir: Optional[Path] = None) -> Optional[Dict]:
    """
    Main download function for Pinterest
    
    Args:
        url: Pinterest URL (pin/board/search)
        max_count: Maximum videos to download for boards/searches
        output_dir: Custom output directory
        
    Returns:
        Dict with download results or None if failed
    """
    downloader = PinterestDownloader(output_dir)
    
    # Detect URL type
    if '/pin/' in url:
        # Single pin
        return downloader.download_pin(url)
    elif '/search/' in url or '?q=' in url:
        # Search results
        results = downloader.download_search(url, max_count)
        return results[0] if results else None
    else:
        # Board URL
        results = downloader.download_board(url, max_count)
        return results[0] if results else None


def check_gallery_dl_installed() -> bool:
    """
    Check if gallery-dl is installed
    
    Returns:
        True if installed, False otherwise
    """
    try:
        subprocess.run(['gallery-dl', '--version'], 
                      capture_output=True, 
                      check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


================================================================================
FILE: downloaders/youtube.py
================================================================================

"""
YouTube downloader using yt-dlp
Supports YouTube videos, Shorts, and audio extraction
"""

import os
import subprocess
import json
from pathlib import Path
from typing import Dict, Optional, List
import yt_dlp

import config


class YouTubeDownloader:
    """Handler for YouTube downloads using yt-dlp"""
    
    def __init__(self, output_dir: Optional[Path] = None):
        """
        Initialize YouTube downloader
        
        Args:
            output_dir: Directory to save downloads (default: config.DOWNLOADS_DIR)
        """
        self.output_dir = output_dir or config.DOWNLOADS_DIR
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # yt-dlp options for video
        self.video_opts = {
            'format': config.YTDLP_FORMAT,
            'outtmpl': str(self.output_dir / '%(title)s_%(id)s.%(ext)s'),
            'quiet': not config.VERBOSE,
            'no_warnings': not config.VERBOSE,
            'extract_flat': False,
            'ignoreerrors': False,
            'merge_output_format': 'mp4',
            'postprocessors': [{
                'key': 'FFmpegVideoConvertor',
                'preferedformat': 'mp4',
            }],
        }
        
        # yt-dlp options for audio only
        self.audio_opts = {
            'format': config.YTDLP_AUDIO_FORMAT,
            'outtmpl': str(self.output_dir / '%(title)s_%(id)s_audio.%(ext)s'),
            'quiet': not config.VERBOSE,
            'no_warnings': not config.VERBOSE,
            'extract_flat': False,
            'ignoreerrors': False,
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': 'm4a',
            }],
        }
    
    def download_video(self, url: str) -> Optional[Dict]:
        """
        Download video from YouTube
        
        Args:
            url: YouTube video/shorts URL
            
        Returns:
            Dict with download info or None if failed
            {
                'video_path': str,
                'title': str,
                'duration': float,
                'url': str,
                'id': str
            }
        """
        try:
            with yt_dlp.YoutubeDL(self.video_opts) as ydl:
                # Extract info first
                info = ydl.extract_info(url, download=False)
                
                if not info:
                    return None
                
                # Download the video
                ydl.download([url])
                
                # Get the downloaded file path
                video_path = ydl.prepare_filename(info)
                
                # Handle format conversion (might have different extension)
                video_path = self._find_downloaded_file(video_path)
                
                if not video_path or not os.path.exists(video_path):
                    return None
                
                return {
                    'video_path': video_path,
                    'title': info.get('title', 'Unknown'),
                    'duration': info.get('duration', 0),
                    'url': url,
                    'id': info.get('id', 'unknown'),
                    'description': info.get('description', ''),
                    'uploader': info.get('uploader', 'Unknown'),
                }
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error downloading video: {str(e)}")
            return None
    
    def download_audio(self, url: str) -> Optional[Dict]:
        """
        Download audio only from YouTube
        
        Args:
            url: YouTube video/shorts URL
            
        Returns:
            Dict with download info or None if failed
        """
        try:
            with yt_dlp.YoutubeDL(self.audio_opts) as ydl:
                # Extract info first
                info = ydl.extract_info(url, download=False)
                
                if not info:
                    return None
                
                # Download the audio
                ydl.download([url])
                
                # Get the downloaded file path
                audio_path = ydl.prepare_filename(info)
                
                # Handle format conversion
                audio_path = self._find_downloaded_file(audio_path, is_audio=True)
                
                if not audio_path or not os.path.exists(audio_path):
                    return None
                
                return {
                    'audio_path': audio_path,
                    'title': info.get('title', 'Unknown'),
                    'duration': info.get('duration', 0),
                    'url': url,
                    'id': info.get('id', 'unknown'),
                }
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error downloading audio: {str(e)}")
            return None
    
    def download_both(self, url: str) -> Optional[Dict]:
        """
        Download both video and audio separately
        
        Args:
            url: YouTube video/shorts URL
            
        Returns:
            Dict with both paths or None if failed
        """
        video_result = self.download_video(url)
        audio_result = self.download_audio(url)
        
        if video_result and audio_result:
            return {
                'video_path': video_result['video_path'],
                'audio_path': audio_result['audio_path'],
                'title': video_result['title'],
                'duration': video_result['duration'],
                'url': url,
                'id': video_result['id'],
            }
        
        return video_result  # Return video only if audio fails
    
    def _find_downloaded_file(self, expected_path: str, is_audio: bool = False) -> Optional[str]:
        """
        Find the actual downloaded file (might have different extension)
        
        Args:
            expected_path: Expected file path from yt-dlp
            is_audio: Whether looking for audio file
            
        Returns:
            Actual file path or None
        """
        # Try exact path first
        if os.path.exists(expected_path):
            return expected_path
        
        # Try without extension and search
        base_path = os.path.splitext(expected_path)[0]
        directory = os.path.dirname(expected_path)
        basename = os.path.basename(base_path)
        
        # Search for files matching the base name
        if os.path.exists(directory):
            for file in os.listdir(directory):
                if file.startswith(basename):
                    full_path = os.path.join(directory, file)
                    
                    # Check if it's the right type
                    ext = os.path.splitext(file)[1].lower()
                    if is_audio and ext in config.AUDIO_EXTENSIONS:
                        return full_path
                    elif not is_audio and ext in config.VIDEO_EXTENSIONS:
                        return full_path
        
        return None
    
    def get_video_info(self, url: str) -> Optional[Dict]:
        """
        Get video information without downloading
        
        Args:
            url: YouTube video/shorts URL
            
        Returns:
            Dict with video info or None
        """
        try:
            with yt_dlp.YoutubeDL({'quiet': True}) as ydl:
                info = ydl.extract_info(url, download=False)
                
                if not info:
                    return None
                
                return {
                    'title': info.get('title', 'Unknown'),
                    'duration': info.get('duration', 0),
                    'url': url,
                    'id': info.get('id', 'unknown'),
                    'description': info.get('description', ''),
                    'uploader': info.get('uploader', 'Unknown'),
                    'view_count': info.get('view_count', 0),
                    'like_count': info.get('like_count', 0),
                }
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error getting video info: {str(e)}")
            return None


def download(url: str, download_audio: bool = False, output_dir: Optional[Path] = None) -> Optional[Dict]:
    """
    Main download function for YouTube
    
    Args:
        url: YouTube video/shorts URL
        download_audio: Whether to download audio separately
        output_dir: Custom output directory
        
    Returns:
        Dict with download results or None if failed
    """
    downloader = YouTubeDownloader(output_dir)
    
    if download_audio:
        return downloader.download_both(url)
    else:
        return downloader.download_video(url)


def download_playlist(playlist_url: str, max_videos: int = 50, download_audio: bool = False) -> List[Dict]:
    """
    Download videos from a YouTube playlist
    
    Args:
        playlist_url: YouTube playlist URL
        max_videos: Maximum number of videos to download
        download_audio: Whether to download audio separately
        
    Returns:
        List of download results
    """
    downloader = YouTubeDownloader()
    results = []
    
    try:
        # Get playlist info
        with yt_dlp.YoutubeDL({'quiet': True, 'extract_flat': True}) as ydl:
            playlist_info = ydl.extract_info(playlist_url, download=False)
            
            if not playlist_info or 'entries' not in playlist_info:
                return results
            
            # Download each video (up to max_videos)
            for i, entry in enumerate(playlist_info['entries'][:max_videos]):
                if not entry:
                    continue
                
                video_url = entry.get('url') or f"https://www.youtube.com/watch?v={entry['id']}"
                
                result = download(video_url, download_audio)
                
                if result:
                    results.append(result)
    
    except Exception as e:
        if config.DEBUG:
            print(f"Error downloading playlist: {str(e)}")
    
    return results


def check_ytdlp_installed() -> bool:
    """
    Check if yt-dlp is installed
    
    Returns:
        True if installed, False otherwise
    """
    try:
        subprocess.run(['yt-dlp', '--version'], 
                      capture_output=True, 
                      check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


================================================================================
FILE: fetch-txt.py
================================================================================

#!/usr/bin/env python3
"""
Extract all Python files from a directory and save to a single text file
Ignores hidden files/folders (starting with .)
"""

import os
from pathlib import Path


def extract_python_files(root_folder, output_file):
    """
    Extract all .py files from root folder and save to output file
    
    Args:
        root_folder: Root directory to search
        output_file: Output text file path
    """
    root_path = Path(root_folder).resolve()
    
    # Check if root folder exists
    if not root_path.exists():
        print(f"❌ Error: Folder '{root_folder}' does not exist")
        return
    
    # Find all .py files
    python_files = []
    
    for item in root_path.rglob("*.py"):
        # Skip hidden files and folders (starting with .)
        parts = item.relative_to(root_path).parts
        
        # Check if any part of path starts with '.'
        if any(part.startswith('.') for part in parts):
            continue
        
        # Check if it's a file (not directory)
        if item.is_file():
            python_files.append(item)
    
    # Sort files by path for organized output
    python_files.sort()
    
    # Write to output file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("=" * 80 + "\n")
        f.write("PYTHON FILES EXTRACTION\n")
        f.write(f"Root Folder: {root_folder}\n")
        f.write(f"Total Files: {len(python_files)}\n")
        f.write("=" * 80 + "\n\n")
        
        for py_file in python_files:
            # Get relative path from root
            relative_path = py_file.relative_to(root_path)
            
            # Write separator
            f.write("\n" + "=" * 80 + "\n")
            f.write(f"FILE: {relative_path}\n")
            f.write("=" * 80 + "\n\n")
            
            # Read and write file content
            try:
                with open(py_file, 'r', encoding='utf-8') as py_content:
                    content = py_content.read()
                    f.write(content)
                    
                    # Add newlines if file doesn't end with newline
                    if not content.endswith('\n'):
                        f.write('\n')
                    
                    f.write("\n")  # Extra newline between files
                
                print(f"✓ Extracted: {relative_path}")
            
            except Exception as e:
                error_msg = f"Error reading file: {str(e)}\n"
                f.write(error_msg)
                print(f"✗ Failed: {relative_path} - {str(e)}")
    
    print(f"\n✅ Extraction complete!")
    print(f"📄 Output saved to: {output_file}")
    print(f"📊 Total files extracted: {len(python_files)}")


def main():
    """Main function"""
    # Configuration
    root_folder = "/Volumes/hard-drive/better-reel-gen"
    output_file = "extracted_python_code.txt"
    
    print("=" * 80)
    print("PYTHON CODE EXTRACTOR")
    print("=" * 80)
    print(f"\nRoot Folder: {root_folder}")
    print(f"Output File: {output_file}")
    print("\nSearching for .py files...\n")
    
    # Extract files
    extract_python_files(root_folder, output_file)


if __name__ == "__main__":
    main()


================================================================================
FILE: main.py
================================================================================

#!/usr/bin/env python3
"""
Better Reel Generator - Main Entry Point
A modular video generator for creating social media content
"""

import sys
import os
import click
from pathlib import Path
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.prompt import Prompt, Confirm
from rich.table import Table

# Import config
import config

# Import modules
from downloaders import youtube, instagram, pinterest
from processors import normalizer, combiner, audio_analyzer, video_cutter, image_overlay
from utils import validators, file_manager, ffmpeg_helper

# Initialize Rich console
console = Console()


# ============================================================================
# MAIN CLI APPLICATION
# ============================================================================

@click.group(invoke_without_command=True)
@click.pass_context
@click.option('--version', is_flag=True, help='Show version')
def cli(ctx, version):
    """
    Better Reel Generator - Create awesome social media videos
    
    Run without arguments for interactive mode, or use flags for automation.
    """
    if version:
        console.print(f"[cyan]{config.APP_NAME} v{config.VERSION}[/cyan]")
        return
    
    if ctx.invoked_subcommand is None:
        # No subcommand = interactive mode
        interactive_mode()


# ============================================================================
# INTERACTIVE MODE
# ============================================================================

def interactive_mode():
    """Guided interactive mode with step-by-step prompts"""
    
    # Display welcome banner
    console.print(Panel.fit(
        f"[bold cyan]{config.APP_NAME}[/bold cyan]\n"
        f"[dim]Version {config.VERSION}[/dim]\n\n"
        "[yellow]Create beat-synced videos from any source[/yellow]",
        border_style="cyan"
    ))
    
    # Show main menu
    console.print("\n[bold cyan]What would you like to do?[/bold cyan]")
    table = Table(show_header=True, header_style="bold cyan")
    table.add_column("Option", style="cyan", width=8)
    table.add_column("Description")
    table.add_row("1", "Generate beat-synced reel (standard workflow)")
    table.add_row("2", "Overlay images on video with animations")
    
    console.print(table)
    
    mode_choice = Prompt.ask(
        "\n[cyan]Choose mode[/cyan]",
        choices=["1", "2"],
        default="1"
    )
    
    try:
        if mode_choice == "1":
            # Standard reel generation workflow
            standard_workflow()
        elif mode_choice == "2":
            # Image overlay workflow
            image_overlay_workflow()
    
    except KeyboardInterrupt:
        console.print("\n[yellow]⚠️  Process interrupted by user[/yellow]")
        sys.exit(0)
    except Exception as e:
        console.print(f"[red]❌ Error: {str(e)}[/red]")
        if config.DEBUG:
            raise


def standard_workflow():
    """Standard beat-synced reel generation workflow"""
    
    # Step 1: Video Source Selection
    console.print("\n[bold cyan]📥 STEP 1: Select Video Source[/bold cyan]")
    video_paths = video_source_phase()
    
    if not video_paths:
        console.print("[red]No videos selected. Exiting.[/red]")
        return
    
    # Step 2: Normalization/Combination Phase
    console.print("\n[bold cyan]🔧 STEP 2: Process Videos[/bold cyan]")
    processed_video = process_videos_phase(video_paths)
    
    if not processed_video:
        console.print("[red]Video processing failed. Exiting.[/red]")
        return
    
    # Step 3: Audio Selection
    console.print("\n[bold cyan]🎵 STEP 3: Select Audio[/bold cyan]")
    audio_path = audio_selection_phase()
    
    if not audio_path:
        console.print("[red]No audio selected. Exiting.[/red]")
        return
    
    # Step 4: Cutting Configuration
    console.print("\n[bold cyan]✂️  STEP 4: Configure Cuts[/bold cyan]")
    cut_config = cutting_configuration_phase(audio_path)
    
    # Step 5: Generate Final Video
    console.print("\n[bold cyan]🎬 STEP 5: Generate Video[/bold cyan]")
    final_video = generate_video_phase(processed_video, audio_path, cut_config)
    
    if final_video:
        console.print(Panel(
            f"[bold green]✅ Success![/bold green]\n\n"
            f"Your video is ready:\n[cyan]{final_video}[/cyan]",
            border_style="green"
        ))
    else:
        console.print("[red]Video generation failed.[/red]")


def image_overlay_workflow():
    """Image overlay workflow"""
    
    console.print("\n[bold cyan]🖼️  IMAGE OVERLAY MODE[/bold cyan]")
    console.print("[dim]Overlay images from a folder onto a background video with animations[/dim]\n")
    
    # Step 1: Select background video
    console.print("[bold cyan]STEP 1: Select Background Video[/bold cyan]")
    
    video_path = None
    while not video_path:
        path_input = Prompt.ask("\n[cyan]Enter background video path[/cyan]")
        
        # Resolve path
        resolved = file_manager.resolve_path(path_input)
        
        if not resolved:
            console.print("[red]Video not found. Please try again.[/red]")
            continue
        
        # Validate video
        is_valid, message = validators.validate_local_video(resolved)
        
        if not is_valid:
            console.print(f"[red]Invalid video: {message}[/red]")
            
            if Confirm.ask("[yellow]Try anyway?[/yellow]", default=False):
                video_path = resolved
            continue
        
        video_path = resolved
        
        # Show video info
        info = ffmpeg_helper.get_video_info(video_path)
        if info:
            console.print(
                f"[green]✓[/green] Video: {Path(video_path).name} "
                f"({info['width']}x{info['height']}, {info['duration']:.1f}s)"
            )
    
    # Step 2: Select images folder
    console.print("\n[bold cyan]STEP 2: Select Images Folder[/bold cyan]")
    
    images_folder = None
    num_images = 0
    
    while not images_folder:
        folder_input = Prompt.ask("\n[cyan]Enter folder path containing images[/cyan]")
        
        # Resolve path
        resolved = file_manager.resolve_path(folder_input)
        
        if not resolved:
            console.print("[red]Folder not found. Please try again.[/red]")
            continue
        
        if not os.path.isdir(resolved):
            console.print("[red]Path is not a folder. Please try again.[/red]")
            continue
        
        # Check for images
        images = image_overlay.get_images_from_folder(resolved)
        
        if not images:
            console.print("[red]No images found in folder. Please try again.[/red]")
            continue
        
        images_folder = resolved
        num_images = len(images)
        
        console.print(f"[green]✓[/green] Found {num_images} images in folder")
        
        # Show first few image names
        console.print("[dim]Images:[/dim]")
        for img in images[:5]:
            console.print(f"  [dim]- {Path(img).name}[/dim]")
        if len(images) > 5:
            console.print(f"  [dim]... and {len(images) - 5} more[/dim]")
    
    # Step 3: Configure timing
    console.print("\n[bold cyan]STEP 3: Configure Timing[/bold cyan]")
    
    video_duration = ffmpeg_helper.get_video_duration(video_path)
    
    # Auto-calculate or manual?
    auto_duration = Confirm.ask(
        f"\n[cyan]Auto-calculate duration per image?[/cyan]\n"
        f"[dim](Video is {video_duration:.1f}s, {num_images} images)[/dim]",
        default=True
    )
    
    duration_per_image = None
    
    if not auto_duration:
        # Manual duration
        default_duration = video_duration / num_images
        duration_input = Prompt.ask(
            f"[cyan]Duration per image (seconds)[/cyan]",
            default=f"{default_duration:.2f}"
        )
        
        try:
            duration_per_image = float(duration_input)
            if duration_per_image <= 0:
                console.print("[yellow]Invalid duration, using auto-calculate[/yellow]")
                duration_per_image = None
        except ValueError:
            console.print("[yellow]Invalid input, using auto-calculate[/yellow]")
            duration_per_image = None
    
    # Delay between images
    use_delay = Confirm.ask(
        "\n[cyan]Add delay between images?[/cyan]",
        default=False
    )
    
    delay_between_images = 0.0
    
    if use_delay:
        delay_input = Prompt.ask(
            "[cyan]Delay duration (seconds)[/cyan]",
            default="0.5"
        )
        
        try:
            delay_between_images = float(delay_input)
            if delay_between_images < 0:
                delay_between_images = 0.0
        except ValueError:
            delay_between_images = 0.0
    
    # Preview timing
    console.print("\n[yellow]📊 Timing Preview:[/yellow]")
    
    preview = image_overlay.preview_image_timing(
        num_images=num_images,
        video_duration=video_duration,
        duration_per_image=duration_per_image,
        delay_between_images=delay_between_images
    )
    
    if preview:
        console.print(f"  Duration per image: [cyan]{preview['duration_per_image']:.2f}s[/cyan]")
        console.print(f"  Delay between images: [cyan]{delay_between_images:.2f}s[/cyan]")
        console.print(f"  Total timeline: [cyan]{preview['total_duration']:.2f}s[/cyan]")
        
        if preview['total_duration'] > video_duration:
            console.print(f"  [yellow]⚠️  Warning: Timeline exceeds video duration (images will be cut off)[/yellow]")
    
    proceed = Confirm.ask("\n[cyan]Proceed with these settings?[/cyan]", default=True)
    
    if not proceed:
        console.print("[yellow]Cancelled by user[/yellow]")
        return
    
    # Step 4: Choose animation style
    console.print("\n[bold cyan]STEP 4: Choose Animation Style[/bold cyan]")
    
    table = Table(show_header=True, header_style="bold cyan")
    table.add_column("Option", style="cyan", width=8)
    table.add_column("Animation Style")
    table.add_row("1", "Random (mix of all styles)")
    table.add_row("2", "Slide from bottom")
    table.add_row("3", "Slide from top")
    table.add_row("4", "Slide from left")
    table.add_row("5", "Slide from right")
    table.add_row("6", "Fade in/out")
    
    console.print(table)
    
    animation_choice = Prompt.ask(
        "\n[cyan]Choose animation style[/cyan]",
        choices=["1", "2", "3", "4", "5", "6"],
        default="1"
    )
    
    animation_map = {
        "1": "random",
        "2": "slide_bottom",
        "3": "slide_top",
        "4": "slide_left",
        "5": "slide_right",
        "6": "fade"
    }
    
    animation_style = animation_map[animation_choice]
    
    # Step 5: Generate video
    console.print("\n[bold cyan]🎬 STEP 5: Generate Video[/bold cyan]")
    
    output_filename = Prompt.ask(
        "\n[cyan]Output filename[/cyan]",
        default="overlay_video.mp4"
    )
    
    output_path = str(config.OUTPUTS_DIR / output_filename)
    
    # Ensure unique path
    output_path = file_manager.ensure_unique_path(output_path)
    
    console.print(f"\n[cyan]Generating video with image overlays...[/cyan]")
    console.print(f"[dim]This may take a few minutes...[/dim]\n")
    
    with console.status("[cyan]Processing...[/cyan]"):
        result = image_overlay.overlay_images_on_video(
            video_path=video_path,
            images_folder=images_folder,
            output_path=output_path,
            duration_per_image=duration_per_image,
            delay_between_images=delay_between_images,
            animation_style=animation_style
        )
    
    if result:
        console.print(Panel(
            f"[bold green]✅ Success![/bold green]\n\n"
            f"Your video with image overlays is ready:\n[cyan]{result}[/cyan]",
            border_style="green"
        ))
    else:
        console.print("[red]❌ Video generation failed[/red]")


# ============================================================================
# PHASE 1: VIDEO SOURCE SELECTION
# ============================================================================

def video_source_phase():
    """Handle video source selection - download, local, or both"""
    
    console.print("\n[dim]Choose where your videos come from[/dim]")
    
    # Display source options
    table = Table(show_header=True, header_style="bold cyan")
    table.add_column("Option", style="cyan", width=8)
    table.add_column("Description")
    table.add_row("1", "Download from URLs (YouTube/Instagram/Pinterest)")
    table.add_row("2", "Use local videos from my device")
    table.add_row("3", "Both (download + local videos)")
    
    console.print(table)
    
    choice = Prompt.ask(
        "\n[cyan]Choose source[/cyan]",
        choices=["1", "2", "3"],
        default="1"
    )
    
    all_videos = []
    
    # Option 1: Download only
    if choice == "1":
        all_videos = download_videos_from_urls()
    
    # Option 2: Local only
    elif choice == "2":
        all_videos = select_local_videos()
    
    # Option 3: Both
    elif choice == "3":
        console.print("\n[yellow]First, let's download videos from URLs...[/yellow]")
        downloaded = download_videos_from_urls()
        
        console.print("\n[yellow]Now, let's add local videos...[/yellow]")
        local = select_local_videos()
        
        all_videos = downloaded + local
        
        if downloaded and local:
            console.print(f"\n[green]✓[/green] Total videos: {len(all_videos)} "
                        f"({len(downloaded)} downloaded + {len(local)} local)")
    
    return all_videos


# ============================================================================
# DOWNLOAD FROM URLS
# ============================================================================

def download_videos_from_urls():
    """Download videos from URLs"""
    
    console.print("\n[dim]You can download from YouTube, Instagram, or Pinterest[/dim]")
    
    # Get URLs from user
    urls = []
    while True:
        url = Prompt.ask(
            f"\n[cyan]Enter URL {len(urls) + 1}[/cyan] (or press Enter to finish)",
            default=""
        )
        
        if not url:
            break
        
        # Validate URL
        if not validators.is_valid_url(url):
            console.print("[red]Invalid URL. Please try again.[/red]")
            continue
        
        urls.append(url)
        console.print(f"[green]✓[/green] Added: {url}")
    
    if not urls:
        console.print("[yellow]No URLs provided.[/yellow]")
        return []
    
    # Ask about audio download
    download_audio = Confirm.ask(
        "\n[cyan]Download audio separately?[/cyan]",
        default=False
    )
    
    # Download videos
    downloaded_videos = []
    
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console
    ) as progress:
        
        for i, url in enumerate(urls, 1):
            task = progress.add_task(
                f"Downloading {i}/{len(urls)}...",
                total=None
            )
            
            try:
                # Detect source and download
                source = validators.detect_source(url)
                
                if source == 'youtube':
                    result = youtube.download(url, download_audio=download_audio)
                elif source == 'instagram':
                    result = instagram.download(url)
                elif source == 'pinterest':
                    result = pinterest.download(url)
                else:
                    console.print(f"[red]Unsupported source: {url}[/red]")
                    continue
                
                if result and result.get('video_path'):
                    downloaded_videos.append(result['video_path'])
                    progress.update(task, completed=True)
                    console.print(f"[green]✓[/green] Downloaded: {Path(result['video_path']).name}")
                else:
                    console.print(f"[red]✗[/red] Failed: {url}")
            
            except Exception as e:
                console.print(f"[red]Error downloading {url}: {str(e)}[/red]")
    
    return downloaded_videos


# ============================================================================
# SELECT LOCAL VIDEOS
# ============================================================================

def select_local_videos():
    """Allow user to select local video files or folders"""
    
    console.print("\n[dim]You can provide video file paths or folder paths[/dim]")
    console.print("[dim]Tip: Use absolute paths or drag-and-drop files into terminal[/dim]")
    
    video_paths = []
    
    while True:
        # Show current count
        if video_paths:
            console.print(f"\n[green]Current selection: {len(video_paths)} video(s)[/green]")
        
        # Ask for input type
        table = Table(show_header=False, box=None)
        table.add_column("Option", style="cyan", width=8)
        table.add_column("Description")
        table.add_row("1", "Add a single video file")
        table.add_row("2", "Add all videos from a folder")
        table.add_row("3", "Done (continue with selected videos)")
        
        console.print(table)
        
        choice = Prompt.ask(
            f"\n[cyan]Choose option[/cyan]",
            choices=["1", "2", "3"],
            default="3" if video_paths else "1"
        )
        
        if choice == "3":
            break
        
        elif choice == "1":
            # Single file
            file_path = Prompt.ask("\n[cyan]Enter video file path[/cyan]")
            
            if not file_path:
                continue
            
            # Resolve path (handle ~, relative paths, etc.)
            resolved_path = file_manager.resolve_path(file_path)
            
            if not resolved_path:
                console.print("[red]File not found. Please check the path.[/red]")
                continue
            
            # Validate video file
            is_valid, message = validators.validate_local_video(resolved_path)
            
            if not is_valid:
                console.print(f"[red]Invalid video: {message}[/red]")
                
                # Ask if user wants to try anyway
                if Confirm.ask("[yellow]Try to use this file anyway?[/yellow]", default=False):
                    video_paths.append(resolved_path)
                    console.print(f"[yellow]⚠[/yellow] Added (not validated): {Path(resolved_path).name}")
                continue
            
            video_paths.append(resolved_path)
            
            # Show file info
            info = ffmpeg_helper.get_video_info(resolved_path)
            if info:
                console.print(
                    f"[green]✓[/green] Added: {Path(resolved_path).name} "
                    f"({info['width']}x{info['height']}, {info['duration']:.1f}s)"
                )
            else:
                console.print(f"[green]✓[/green] Added: {Path(resolved_path).name}")
        
        elif choice == "2":
            # Folder of videos
            folder_path = Prompt.ask("\n[cyan]Enter folder path[/cyan]")
            
            if not folder_path:
                continue
            
            # Resolve path
            resolved_path = file_manager.resolve_path(folder_path)
            
            if not resolved_path or not os.path.isdir(resolved_path):
                console.print("[red]Folder not found. Please check the path.[/red]")
                continue
            
            # Check if folder has videos
            has_videos, count = validators.is_video_folder(resolved_path)
            
            if not has_videos:
                console.print("[red]No video files found in this folder.[/red]")
                continue
            
            # Find all videos
            console.print(f"\n[yellow]Found {count} video(s) in folder[/yellow]")
            
            # Ask if recursive search
            recursive = Confirm.ask(
                "[cyan]Search in subfolders too?[/cyan]",
                default=False
            )
            
            found_videos = file_manager.find_videos_in_folder(resolved_path, recursive)
            
            if recursive and len(found_videos) > count:
                console.print(f"[yellow]Found {len(found_videos)} total videos (including subfolders)[/yellow]")
            
            # Ask to select all or individual
            if len(found_videos) <= 10:
                # Few videos - show list and ask individually
                console.print("\n[bold]Select videos to include:[/bold]")
                
                for video in found_videos:
                    # Get video info for display
                    info = ffmpeg_helper.get_video_info(video)
                    display_name = Path(video).name
                    
                    if info:
                        display_info = f"{display_name} ({info['width']}x{info['height']}, {info['duration']:.1f}s)"
                    else:
                        display_info = display_name
                    
                    if Confirm.ask(f"[cyan]Include {display_info}?[/cyan]", default=True):
                        video_paths.append(video)
                        console.print(f"[green]✓[/green] Added")
            else:
                # Many videos - ask to include all or filter
                console.print(f"\n[yellow]Found {len(found_videos)} videos[/yellow]")
                
                include_all = Confirm.ask(
                    "[cyan]Include all videos from this folder?[/cyan]",
                    default=True
                )
                
                if include_all:
                    video_paths.extend(found_videos)
                    console.print(f"[green]✓[/green] Added {len(found_videos)} videos")
                else:
                    # Filter by criteria
                    console.print("\n[yellow]Let's filter the videos...[/yellow]")
                    
                    # Ask for minimum duration
                    min_duration = Prompt.ask(
                        "[cyan]Minimum video duration (seconds)[/cyan]",
                        default="0"
                    )
                    
                    try:
                        min_duration = float(min_duration)
                    except ValueError:
                        min_duration = 0.0
                    
                    # Filter videos
                    filtered_count = 0
                    for video in found_videos:
                        info = ffmpeg_helper.get_video_info(video)
                        if info and info['duration'] >= min_duration:
                            video_paths.append(video)
                            filtered_count += 1
                    
                    console.print(f"[green]✓[/green] Added {filtered_count} videos (duration >= {min_duration}s)")
    
    # Summary
    if video_paths:
        console.print(f"\n[green]✓[/green] Selected {len(video_paths)} local video(s)")
    else:
        console.print("\n[yellow]No local videos selected[/yellow]")
    
    return video_paths


# ============================================================================
# PHASE 2: PROCESS VIDEOS
# ============================================================================

def process_videos_phase(video_paths):
    """Normalize and combine videos if multiple"""
    
    if not video_paths:
        return None
    
    # Single video - ask if processing needed
    if len(video_paths) == 1:
        console.print(f"\n[green]✓[/green] Single video: {Path(video_paths[0]).name}")
        
        needs_processing = Confirm.ask(
            "[cyan]Normalize this video? (crop to 9:16, fix fps, etc.)[/cyan]",
            default=True
        )
        
        if needs_processing:
            with console.status("[cyan]Normalizing video...[/cyan]"):
                normalized = normalizer.normalize_video(
                    video_paths[0],
                    target_resolution=config.RESOLUTIONS['reels']
                )
            
            if normalized:
                console.print(f"[green]✓[/green] Normalized: {Path(normalized).name}")
                return normalized
        
        return video_paths[0]
    
    # Multiple videos - normalize and combine
    console.print(f"\n[yellow]Found {len(video_paths)} videos[/yellow]")
    
    # Ask user preference
    table = Table(show_header=True, header_style="bold cyan")
    table.add_column("Option", style="cyan")
    table.add_column("Description")
    table.add_row("1", "Process all videos (normalize + combine)")
    table.add_row("2", "Select specific videos to process")
    table.add_row("3", "Use first video only")
    
    console.print(table)
    
    choice = Prompt.ask(
        "\n[cyan]Choose an option[/cyan]",
        choices=["1", "2", "3"],
        default="1"
    )
    
    if choice == "3":
        return video_paths[0]
    
    if choice == "2":
        # Let user select videos
        selected = []
        console.print("\n[bold]Select videos to include:[/bold]")
        for i, path in enumerate(video_paths, 1):
            if Confirm.ask(f"[cyan]{i}. Include {Path(path).name}?[/cyan]", default=True):
                selected.append(path)
        video_paths = selected
    
    # Normalize all videos
    console.print("\n[cyan]Normalizing videos...[/cyan]")
    normalized_videos = []
    
    with Progress(console=console) as progress:
        task = progress.add_task(
            "[cyan]Normalizing...",
            total=len(video_paths)
        )
        
        for video in video_paths:
            try:
                normalized = normalizer.normalize_video(
                    video,
                    target_resolution=config.RESOLUTIONS['reels']
                )
                
                if normalized:
                    normalized_videos.append(normalized)
                    console.print(f"[green]✓[/green] {Path(video).name}")
                
                progress.update(task, advance=1)
            
            except Exception as e:
                console.print(f"[red]✗[/red] Failed {Path(video).name}: {str(e)}")
    
    if not normalized_videos:
        console.print("[red]No videos were normalized successfully.[/red]")
        return None
    
    # Combine videos
    console.print("\n[cyan]Combining videos...[/cyan]")
    
    with console.status("[cyan]Merging...[/cyan]"):
        combined = combiner.merge_videos(
            normalized_videos,
            output_path=config.OUTPUTS_DIR / "combined_video.mp4"
        )
    
    if combined:
        console.print(f"[green]✓[/green] Combined: {Path(combined).name}")
        return combined
    
    return None


# ============================================================================
# PHASE 3: AUDIO SELECTION
# ============================================================================

def audio_selection_phase():
    """Get audio file from user"""
    
    console.print("\n[dim]Provide the audio file to sync with video[/dim]")
    
    while True:
        audio_path = Prompt.ask(
            "\n[cyan]Enter audio file path[/cyan]"
        )
        
        # Resolve path
        resolved_path = file_manager.resolve_path(audio_path)
        
        if not resolved_path:
            console.print("[red]File not found. Please try again.[/red]")
            continue
        
        # Validate audio file
        if not validators.is_valid_audio(resolved_path):
            console.print("[red]Invalid audio file. Please provide MP3, WAV, M4A, etc.[/red]")
            continue
        
        # Get audio info
        info = ffmpeg_helper.get_audio_info(resolved_path)
        if info:
            console.print(
                f"[green]✓[/green] Audio: {Path(resolved_path).name} "
                f"({info['duration']:.1f}s, {info['codec']})"
            )
        else:
            console.print(f"[green]✓[/green] Audio: {Path(resolved_path).name}")
        
        return resolved_path


# ============================================================================
# PHASE 4: CUTTING CONFIGURATION
# ============================================================================

def cutting_configuration_phase(audio_path):
    """Configure how to cut the video"""
    
    config_dict = {}
    
    # Cut mode
    console.print("\n[bold]Cut Mode:[/bold]")
    table = Table(show_header=False)
    table.add_column("Option", style="cyan")
    table.add_column("Description")
    table.add_row("1", "Beat Detection (sync to music beats)")
    table.add_row("2", "Vocal Changes (sync to vocals)")
    
    console.print(table)
    
    cut_choice = Prompt.ask(
        "\n[cyan]Choose cut mode[/cyan]",
        choices=["1", "2"],
        default="1"
    )
    
    config_dict['cut_mode'] = 'beats' if cut_choice == "1" else 'vocals'
    
    # Interval
    console.print("\n[bold]Cut Interval:[/bold]")
    config_dict['interval'] = int(Prompt.ask(
        "[cyan]Cut every N points[/cyan] (1 = every beat, 5 = every 5th beat)",
        default="5"
    ))
    
    # Order
    console.print("\n[bold]Segment Order:[/bold]")
    table = Table(show_header=False)
    table.add_column("Option", style="cyan")
    table.add_column("Description")
    table.add_row("1", "Sequential (keep in order)")
    table.add_row("2", "Random (shuffle segments)")
    
    console.print(table)
    
    order_choice = Prompt.ask(
        "\n[cyan]Choose order[/cyan]",
        choices=["1", "2"],
        default="1"
    )
    
    config_dict['order'] = 'sequential' if order_choice == "1" else 'random'
    
    # Audio duration
    console.print("\n[bold]Audio Duration:[/bold]")
    
    # Get audio duration
    audio_duration = ffmpeg_helper.get_audio_duration(audio_path)
    console.print(f"[dim]Total audio duration: {audio_duration:.2f} seconds[/dim]")
    
    use_full = Confirm.ask(
        "\n[cyan]Use full audio?[/cyan]",
        default=True
    )
    
    if use_full:
        config_dict['audio_start'] = 0
        config_dict['audio_end'] = audio_duration
    else:
        config_dict['audio_start'] = float(Prompt.ask(
            "[cyan]Start time (seconds)[/cyan]",
            default="0"
        ))
        
        config_dict['audio_end'] = float(Prompt.ask(
            "[cyan]End time (seconds)[/cyan]",
            default=str(audio_duration)
        ))
    
    return config_dict


# ============================================================================
# PHASE 5: GENERATE VIDEO
# ============================================================================

def generate_video_phase(video_path, audio_path, cut_config):
    """Generate the final video"""
    
    try:
        # Analyze audio
        console.print("\n[cyan]Analyzing audio...[/cyan]")
        
        with console.status("[cyan]Detecting beats/vocals...[/cyan]"):
            if cut_config['cut_mode'] == 'beats':
                cut_points = audio_analyzer.detect_beats(audio_path)
            else:
                cut_points = audio_analyzer.detect_vocal_changes(audio_path)
        
        console.print(f"[green]✓[/green] Found {len(cut_points)} cut points")
        
        # Filter by interval
        filtered_points = cut_points[::cut_config['interval']]
        console.print(f"[green]✓[/green] Using {len(filtered_points)} points (every {cut_config['interval']}th)")
        
        # Cut video
        console.print("\n[cyan]Cutting video segments...[/cyan]")
        
        with console.status("[cyan]Creating segments...[/cyan]"):
            segments = video_cutter.create_segments(
                video_path=video_path,
                cut_points=filtered_points,
                order=cut_config['order'],
                audio_duration=cut_config['audio_end'] - cut_config['audio_start']
            )
        
        console.print(f"[green]✓[/green] Created {len(segments)} segments")
        
        # Merge with audio
        console.print("\n[cyan]Generating final video...[/cyan]")
        
        output_path = config.OUTPUTS_DIR / f"final_reel_{Path(video_path).stem}.mp4"
        
        with console.status("[cyan]Merging segments with audio...[/cyan]"):
            final_video = video_cutter.merge_with_audio(
                segments=segments,
                audio_path=audio_path,
                audio_start=cut_config['audio_start'],
                audio_end=cut_config['audio_end'],
                output_path=str(output_path)
            )
        
        return final_video
    
    except Exception as e:
        console.print(f"[red]Error during generation: {str(e)}[/red]")
        if config.DEBUG:
            raise
        return None


# ============================================================================
# CLI SUBCOMMANDS (for flag-based usage)
# ============================================================================

@cli.command()
@click.option('--urls', help='Comma-separated URLs to download')
@click.option('--local-videos', help='Comma-separated local video paths')
@click.option('--local-folder', help='Folder containing local videos')
@click.option('--download-audio', is_flag=True, help='Download audio separately')
@click.option('--audio-path', required=True, help='Path to audio file')
@click.option('--cut-mode', type=click.Choice(['beats', 'vocals']), default='beats')
@click.option('--interval', type=int, default=5, help='Cut every N points')
@click.option('--order', type=click.Choice(['sequential', 'random']), default='sequential')
@click.option('--audio-start', type=float, default=0, help='Audio start time (seconds)')
@click.option('--audio-end', type=float, default=None, help='Audio end time (seconds)')
@click.option('--output', default='final_reel.mp4', help='Output filename')
def generate(urls, local_videos, local_folder, download_audio, audio_path, cut_mode, 
            interval, order, audio_start, audio_end, output):
    """Generate video using command-line flags (non-interactive)"""
    
    console.print(Panel.fit(
        "[bold cyan]Better Reel Generator[/bold cyan]\n[dim]Non-interactive mode[/dim]",
        border_style="cyan"
    ))
    
    try:
        all_videos = []
        
        # Download from URLs
        if urls:
            url_list = [u.strip() for u in urls.split(',')]
            console.print(f"\n[cyan]📥 Downloading {len(url_list)} video(s)...[/cyan]")
            
            for url in url_list:
                source = validators.detect_source(url)
                if source == 'youtube':
                    result = youtube.download(url, download_audio=download_audio)
                elif source == 'instagram':
                    result = instagram.download(url)
                elif source == 'pinterest':
                    result = pinterest.download(url)
                else:
                    continue
                
                if result and result.get('video_path'):
                    all_videos.append(result['video_path'])
        
        # Add local videos
        if local_videos:
            video_list = [v.strip() for v in local_videos.split(',')]
            for video in video_list:
                resolved = file_manager.resolve_path(video)
                if resolved and validators.is_valid_video(resolved):
                    all_videos.append(resolved)
        
        # Add videos from folder
        if local_folder:
            resolved_folder = file_manager.resolve_path(local_folder)
            if resolved_folder:
                folder_videos = file_manager.find_videos_in_folder(resolved_folder)
                all_videos.extend(folder_videos)
        
        if not all_videos:
            console.print("[red]No valid videos found.[/red]")
            sys.exit(1)
        
        console.print(f"[green]✓[/green] Found {len(all_videos)} video(s)")
        
        # Process videos - ALWAYS NORMALIZE TO REEL FORMAT
        console.print("\n[cyan]🔧 Processing videos...[/cyan]")
        console.print("[cyan]Normalizing to reel format (1080x1920)...[/cyan]")
        
        if len(all_videos) == 1:
            # Single video - normalize it
            with console.status("[cyan]Normalizing video...[/cyan]"):
                processed = normalizer.normalize_video(
                    all_videos[0],
                    target_resolution=config.RESOLUTIONS['reels'],
                    target_fps=config.TARGET_FPS,
                    crop_mode='center'
                )
            
            if not processed:
                console.print("[red]❌ Video normalization failed[/red]")
                sys.exit(1)
            
            console.print(f"[green]✓[/green] Normalized to 1080x1920")
        else:
            # Multiple videos - normalize all then merge
            normalized = normalizer.batch_normalize(
                all_videos,
                target_resolution=config.RESOLUTIONS['reels'],
                target_fps=config.TARGET_FPS
            )
            
            if not normalized:
                console.print("[red]❌ Video normalization failed[/red]")
                sys.exit(1)
            
            processed = combiner.merge_videos(normalized)
            
            if not processed:
                console.print("[red]❌ Video merging failed[/red]")
                sys.exit(1)
            
            console.print(f"[green]✓[/green] Normalized and combined {len(normalized)} videos")
        
        # Analyze audio
        console.print("\n[cyan]🎵 Analyzing audio...[/cyan]")
        if cut_mode == 'beats':
            cut_points = audio_analyzer.detect_beats(audio_path)
        else:
            cut_points = audio_analyzer.detect_vocal_changes(audio_path)
        
        console.print(f"[green]✓[/green] Found {len(cut_points)} cut points")
        
        filtered_points = cut_points[::interval]
        console.print(f"[green]✓[/green] Using {len(filtered_points)} points (every {interval})")
        
        # Generate video
        console.print("\n[cyan]🎬 Generating video...[/cyan]")
        
        audio_duration = audio_end if audio_end else ffmpeg_helper.get_audio_duration(audio_path)
        
        segments = video_cutter.create_segments(
            video_path=processed,
            cut_points=filtered_points,
            order=order,
            audio_duration=audio_duration - audio_start
        )
        
        console.print(f"[green]✓[/green] Created {len(segments)} segments")
        
        final = video_cutter.merge_with_audio(
            segments=segments,
            audio_path=audio_path,
            audio_start=audio_start,
            audio_end=audio_duration,
            output_path=str(config.OUTPUTS_DIR / output)
        )
        
        if final:
            console.print(f"\n[green]✅ Video saved: {final}[/green]")
        else:
            console.print("[red]❌ Generation failed[/red]")
            sys.exit(1)
    
    except Exception as e:
        console.print(f"[red]❌ Error: {str(e)}[/red]")
        if config.DEBUG:
            raise
        sys.exit(1)


@cli.command()
@click.option('--video', required=True, help='Background video path')
@click.option('--images-folder', required=True, help='Folder containing images')
@click.option('--duration-per-image', type=float, help='Duration each image shows (auto if not set)')
@click.option('--delay', type=float, default=0.0, help='Delay between images in seconds')
@click.option('--animation', default='random', 
              type=click.Choice(['random', 'slide_bottom', 'slide_top', 'slide_left', 'slide_right', 'fade']),
              help='Animation style')
@click.option('--output', default='overlay_video.mp4', help='Output filename')
def overlay_images(video, images_folder, duration_per_image, delay, animation, output):
    """Overlay images from folder onto background video with animations"""
    
    console.print(Panel.fit(
        "[bold cyan]Image Overlay Mode[/bold cyan]\n[dim]Non-interactive mode[/dim]",
        border_style="cyan"
    ))
    
    try:
        # Validate inputs
        is_valid, message = image_overlay.validate_overlay_inputs(
            video_path=video,
            images_folder=images_folder,
            duration_per_image=duration_per_image
        )
        
        if not is_valid:
            console.print(f"[red]❌ Validation failed: {message}[/red]")
            sys.exit(1)
        
        console.print(f"[green]✓[/green] {message}")
        
        # Get images count
        images = image_overlay.get_images_from_folder(images_folder)
        console.print(f"[cyan]Found {len(images)} images[/cyan]")
        
        # Preview timing
        video_duration = ffmpeg_helper.get_video_duration(video)
        preview = image_overlay.preview_image_timing(
            num_images=len(images),
            video_duration=video_duration,
            duration_per_image=duration_per_image,
            delay_between_images=delay
        )
        
        if preview:
            console.print(f"[dim]Duration per image: {preview['duration_per_image']:.2f}s[/dim]")
            console.print(f"[dim]Total timeline: {preview['total_duration']:.2f}s[/dim]")
        
        # Generate output path
        output_path = str(config.OUTPUTS_DIR / output)
        output_path = file_manager.ensure_unique_path(output_path)
        
        console.print(f"\n[cyan]🎬 Generating video with image overlays...[/cyan]")
        console.print(f"[dim]This may take a few minutes...[/dim]\n")
        
        # Process
        with console.status("[cyan]Processing...[/cyan]"):
            result = image_overlay.overlay_images_on_video(
                video_path=video,
                images_folder=images_folder,
                output_path=output_path,
                duration_per_image=duration_per_image,
                delay_between_images=delay,
                animation_style=animation
            )
        
        if result:
            console.print(f"\n[green]✅ Video saved: {result}[/green]")
        else:
            console.print("[red]❌ Generation failed[/red]")
            sys.exit(1)
    
    except Exception as e:
        console.print(f"[red]❌ Error: {str(e)}[/red]")
        if config.DEBUG:
            raise
        sys.exit(1)


# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

if __name__ == '__main__':
    # Check for FFmpeg
    if not ffmpeg_helper.check_ffmpeg():
        console.print("[red]❌ FFmpeg not found. Please install FFmpeg first.[/red]")
        console.print("[yellow]Install: brew install ffmpeg (macOS) or apt install ffmpeg (Linux)[/yellow]")
        sys.exit(1)
    
    cli()


================================================================================
FILE: processors/__init__.py
================================================================================

"""
Processors module for Better Reel Generator
Handles video normalization, combination, audio analysis, cutting, and image overlay
"""

from .normalizer import normalize_video, batch_normalize
from .combiner import merge_videos, concatenate_segments
from .audio_analyzer import detect_beats, detect_vocal_changes, analyze_audio
from .video_cutter import create_segments, merge_with_audio, extract_segment
from .image_overlay import (
    overlay_images_on_video,
    preview_image_timing,
    get_images_from_folder,
    validate_overlay_inputs,
    ImageOverlayProcessor
)

__all__ = [
    # Normalizer
    'normalize_video',
    'batch_normalize',
    
    # Combiner
    'merge_videos',
    'concatenate_segments',
    
    # Audio Analyzer
    'detect_beats',
    'detect_vocal_changes',
    'analyze_audio',
    
    # Video Cutter
    'create_segments',
    'merge_with_audio',
    'extract_segment',
    
    # Image Overlay
    'overlay_images_on_video',
    'preview_image_timing',
    'get_images_from_folder',
    'validate_overlay_inputs',
    'ImageOverlayProcessor',
]

__version__ = '1.0.0'


================================================================================
FILE: processors/audio_analyzer.py
================================================================================

"""
Audio Analyzer - Detect beats and vocal changes in audio
Uses librosa for audio analysis
"""

import os
import numpy as np
from pathlib import Path
from typing import List, Optional, Dict, Tuple
import librosa
from scipy.ndimage import gaussian_filter1d

import config


class AudioAnalyzer:
    """Handler for audio analysis using librosa"""
    
    def __init__(self):
        """Initialize audio analyzer"""
        self.cache_dir = config.TEMP_DIR / "audio_cache"
        self.cache_dir.mkdir(parents=True, exist_ok=True)
    
    def analyze_beats(
        self,
        audio_path: str,
        hop_length: int = None,
        start_bpm: float = None
    ) -> List[float]:
        """
        Detect beat timestamps in audio
        
        Args:
            audio_path: Path to audio file
            hop_length: Number of samples between frames
            start_bpm: Initial BPM estimate
            
        Returns:
            List of beat timestamps in seconds
        """
        try:
            if not os.path.exists(audio_path):
                if config.DEBUG:
                    print(f"Audio file not found: {audio_path}")
                return []
            
            # Load audio
            y, sr = librosa.load(audio_path, sr=None)
            
            # Use config defaults if not provided
            if hop_length is None:
                hop_length = config.BEAT_HOP_LENGTH
            
            if start_bpm is None:
                start_bpm = config.BEAT_START_BPM
            
            # Detect beats
            tempo, beat_frames = librosa.beat.beat_track(
                y=y,
                sr=sr,
                hop_length=hop_length,
                start_bpm=start_bpm,
                units='frames'
            )
            
            # Convert frames to time
            beat_times = librosa.frames_to_time(beat_frames, sr=sr, hop_length=hop_length)
            
            # Convert to Python list
            beat_times_list = beat_times.tolist() if hasattr(beat_times, 'tolist') else list(beat_times)
            
            if config.VERBOSE:
                print(f"Detected {len(beat_times_list)} beats")
                print(f"Estimated tempo: {tempo:.2f} BPM")
            
            return beat_times_list
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error detecting beats: {str(e)}")
            return []
    
    def analyze_vocal_changes(
        self,
        audio_path: str,
        threshold: float = None
    ) -> List[float]:
        """
        Detect vocal change points in audio
        
        Args:
            audio_path: Path to audio file
            threshold: Sensitivity threshold (lower = more sensitive)
            
        Returns:
            List of vocal change timestamps in seconds
        """
        try:
            if not os.path.exists(audio_path):
                if config.DEBUG:
                    print(f"Audio file not found: {audio_path}")
                return []
            
            # Load audio
            y, sr = librosa.load(audio_path, sr=None)
            
            # Use config default if not provided
            if threshold is None:
                threshold = config.VOCAL_THRESHOLD
            
            # Separate harmonic (vocal) and percussive components
            y_harmonic, y_percussive = librosa.effects.hpss(y)
            
            # Compute mel spectrogram for harmonic part
            mel_spect = librosa.feature.melspectrogram(
                y=y_harmonic,
                sr=sr,
                n_mels=128,
                fmax=8000
            )
            
            # Convert to log scale
            mel_spect_db = librosa.power_to_db(mel_spect, ref=np.max)
            
            # Compute spectral contrast
            contrast = librosa.feature.spectral_contrast(
                S=np.abs(librosa.stft(y_harmonic)),
                sr=sr
            )
            
            # Combine features
            feature_sum = np.mean(contrast, axis=0) + np.mean(mel_spect_db, axis=0)
            
            # Normalize
            feature_sum = librosa.util.normalize(feature_sum)
            
            # Smooth the signal
            feature_smooth = gaussian_filter1d(feature_sum, sigma=3)
            
            # Find peaks (vocal changes)
            peaks = librosa.util.peak_pick(
                feature_smooth,
                pre_max=20,
                post_max=20,
                pre_avg=20,
                post_avg=20,
                delta=threshold,
                wait=1
            )
            
            # Convert frames to time
            vocal_times = librosa.frames_to_time(peaks, sr=sr)
            
            # Convert to Python list
            vocal_times_list = vocal_times.tolist() if hasattr(vocal_times, 'tolist') else list(vocal_times)
            
            # Ensure minimum number of changes
            if len(vocal_times_list) < config.VOCAL_MIN_CHANGES:
                # Fallback to onset detection with different parameters
                onset_env = librosa.onset.onset_strength(y=y, sr=sr)
                peaks = librosa.util.peak_pick(
                    onset_env,
                    pre_max=20,
                    post_max=20,
                    pre_avg=20,
                    post_avg=20,
                    delta=threshold / 2,
                    wait=1
                )
                vocal_times = librosa.frames_to_time(peaks, sr=sr)
                vocal_times_list = vocal_times.tolist() if hasattr(vocal_times, 'tolist') else list(vocal_times)
            
            if config.VERBOSE:
                print(f"Detected {len(vocal_times_list)} vocal changes")
            
            return vocal_times_list
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error detecting vocal changes: {str(e)}")
            return []
    
    def analyze_hybrid(
        self,
        audio_path: str,
        beat_weight: float = 0.7,
        vocal_weight: float = 0.3
    ) -> List[float]:
        """
        Combine beat and vocal detection for hybrid analysis
        
        Args:
            audio_path: Path to audio file
            beat_weight: Weight for beat detection (0-1)
            vocal_weight: Weight for vocal detection (0-1)
            
        Returns:
            List of combined timestamps
        """
        try:
            # Get both beat and vocal times
            beat_times = self.analyze_beats(audio_path)
            vocal_times = self.analyze_vocal_changes(audio_path)
            
            # Combine and sort
            all_times = []
            
            # Add beats with weight
            for beat_time in beat_times:
                all_times.append((beat_time, beat_weight))
            
            # Add vocals with weight
            for vocal_time in vocal_times:
                all_times.append((vocal_time, vocal_weight))
            
            # Sort by time
            all_times.sort(key=lambda x: x[0])
            
            # Merge nearby points (within 0.1 seconds)
            merged_times = []
            last_time = -1.0
            
            for time, weight in all_times:
                if time - last_time > 0.1:
                    merged_times.append(time)
                    last_time = time
            
            return merged_times
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error in hybrid analysis: {str(e)}")
            return []
    
    def get_audio_info(self, audio_path: str) -> Optional[Dict]:
        """
        Get audio file information
        
        Args:
            audio_path: Path to audio file
            
        Returns:
            Dict with audio info or None
        """
        try:
            if not os.path.exists(audio_path):
                return None
            
            # Load audio
            y, sr = librosa.load(audio_path, sr=None)
            
            # Get duration
            duration = librosa.get_duration(y=y, sr=sr)
            
            # Estimate tempo
            tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
            
            # Get spectral features
            spectral_centroids = librosa.feature.spectral_centroid(y=y, sr=sr)
            spectral_rolloff = librosa.feature.spectral_rolloff(y=y, sr=sr)
            
            return {
                'duration': duration,
                'sample_rate': sr,
                'tempo': float(tempo),
                'samples': len(y),
                'channels': 1,  # librosa loads as mono by default
                'spectral_centroid_mean': float(np.mean(spectral_centroids)),
                'spectral_rolloff_mean': float(np.mean(spectral_rolloff)),
            }
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error getting audio info: {str(e)}")
            return None
    
    def get_audio_duration(self, audio_path: str) -> float:
        """
        Get audio duration in seconds
        
        Args:
            audio_path: Path to audio file
            
        Returns:
            Duration in seconds, or 0.0 if error
        """
        try:
            info = self.get_audio_info(audio_path)
            return info['duration'] if info else 0.0
        except Exception:
            return 0.0
    
    def validate_audio(self, audio_path: str) -> bool:
        """
        Check if audio file is valid
        
        Args:
            audio_path: Path to audio file
            
        Returns:
            True if valid, False otherwise
        """
        try:
            info = self.get_audio_info(audio_path)
            return info is not None and info['duration'] > 0
        except Exception:
            return False


def detect_beats(audio_path: str, hop_length: int = None) -> List[float]:
    """
    Main function to detect beats in audio
    
    Args:
        audio_path: Path to audio file
        hop_length: Number of samples between frames
        
    Returns:
        List of beat timestamps in seconds
    """
    analyzer = AudioAnalyzer()
    return analyzer.analyze_beats(audio_path, hop_length=hop_length)


def detect_vocal_changes(audio_path: str, threshold: float = None) -> List[float]:
    """
    Main function to detect vocal changes in audio
    
    Args:
        audio_path: Path to audio file
        threshold: Sensitivity threshold
        
    Returns:
        List of vocal change timestamps in seconds
    """
    analyzer = AudioAnalyzer()
    return analyzer.analyze_vocal_changes(audio_path, threshold=threshold)


def analyze_audio(
    audio_path: str,
    mode: str = 'beats',
    **kwargs
) -> List[float]:
    """
    Analyze audio with specified mode
    
    Args:
        audio_path: Path to audio file
        mode: Analysis mode ('beats', 'vocals', 'hybrid')
        **kwargs: Additional arguments for specific analyzers
        
    Returns:
        List of timestamps in seconds
    """
    analyzer = AudioAnalyzer()
    
    if mode == 'beats':
        return analyzer.analyze_beats(audio_path, **kwargs)
    elif mode == 'vocals':
        return analyzer.analyze_vocal_changes(audio_path, **kwargs)
    elif mode == 'hybrid':
        return analyzer.analyze_hybrid(audio_path, **kwargs)
    else:
        if config.DEBUG:
            print(f"Unknown analysis mode: {mode}")
        return []


def get_audio_duration(audio_path: str) -> float:
    """
    Get audio file duration
    
    Args:
        audio_path: Path to audio file
        
    Returns:
        Duration in seconds
    """
    analyzer = AudioAnalyzer()
    return analyzer.get_audio_duration(audio_path)


def get_audio_info(audio_path: str) -> Optional[Dict]:
    """
    Get detailed audio file information
    
    Args:
        audio_path: Path to audio file
        
    Returns:
        Dict with audio info or None
    """
    analyzer = AudioAnalyzer()
    return analyzer.get_audio_info(audio_path)


================================================================================
FILE: processors/combiner.py
================================================================================

"""
Video Combiner - Merge multiple videos into one
Handles concatenation with proper audio sync
"""

import os
import subprocess
import tempfile
from pathlib import Path
from typing import List, Optional, Dict
import ffmpeg

import config


class VideoCombiner:
    """Handler for combining multiple videos"""
    
    def __init__(self):
        """Initialize video combiner"""
        self.temp_dir = config.TEMP_DIR
        self.temp_dir.mkdir(parents=True, exist_ok=True)
    
    def merge(
        self,
        video_paths: List[str],
        output_path: Optional[str] = None,
        transition: Optional[str] = None,
        transition_duration: float = 0.5
    ) -> Optional[str]:
        """
        Merge multiple videos into one
        
        Args:
            video_paths: List of video file paths
            output_path: Output file path (optional)
            transition: Transition type ('fade', 'dissolve', None)
            transition_duration: Duration of transition in seconds
            
        Returns:
            Path to merged video or None if failed
        """
        try:
            if not video_paths:
                return None
            
            # Single video - just return it
            if len(video_paths) == 1:
                return video_paths[0]
            
            # Verify all videos exist
            for video_path in video_paths:
                if not os.path.exists(video_path):
                    if config.DEBUG:
                        print(f"Video not found: {video_path}")
                    return None
            
            # Determine output path
            if output_path is None:
                output_path = str(config.OUTPUTS_DIR / "combined_video.mp4")
            
            # Choose merge method based on transition
            if transition:
                return self._merge_with_transition(
                    video_paths,
                    output_path,
                    transition,
                    transition_duration
                )
            else:
                return self._merge_simple_concat(video_paths, output_path)
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error merging videos: {str(e)}")
            return None
    
    def _merge_simple_concat(
        self,
        video_paths: List[str],
        output_path: str
    ) -> Optional[str]:
        """
        Simple concatenation using FFmpeg concat demuxer
        (Fast, but requires all videos to have same specs)
        
        Args:
            video_paths: List of video paths
            output_path: Output path
            
        Returns:
            Output path or None
        """
        try:
            # Create concat file
            concat_file = self.temp_dir / "concat_list.txt"
            
            with open(concat_file, 'w') as f:
                for video_path in video_paths:
                    # Write absolute path
                    abs_path = os.path.abspath(video_path)
                    f.write(f"file '{abs_path}'\n")
            
            # Run FFmpeg concat
            cmd = [
                'ffmpeg',
                '-f', 'concat',
                '-safe', '0',
                '-i', str(concat_file),
                '-c', 'copy',  # Copy streams (no re-encoding)
                '-y',  # Overwrite output
                output_path
            ]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True
            )
            
            # Clean up concat file
            if concat_file.exists():
                concat_file.unlink()
            
            if result.returncode == 0 and os.path.exists(output_path):
                return output_path
            
            # If concat failed, try re-encoding method
            if config.DEBUG:
                print("Concat demuxer failed, trying re-encode method...")
            
            return self._merge_with_reencoding(video_paths, output_path)
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error in simple concat: {str(e)}")
            return self._merge_with_reencoding(video_paths, output_path)
    
    def _merge_with_reencoding(
        self,
        video_paths: List[str],
        output_path: str
    ) -> Optional[str]:
        """
        Merge videos with re-encoding (slower but more reliable)
        
        Args:
            video_paths: List of video paths
            output_path: Output path
            
        Returns:
            Output path or None
        """
        try:
            # Build filter_complex for concatenation
            filter_parts = []
            
            for i in range(len(video_paths)):
                filter_parts.append(f"[{i}:v][{i}:a]")
            
            filter_complex = (
                f"{''.join(filter_parts)}"
                f"concat=n={len(video_paths)}:v=1:a=1[outv][outa]"
            )
            
            # Build FFmpeg command
            cmd = ['ffmpeg']
            
            # Add all input files
            for video_path in video_paths:
                cmd.extend(['-i', video_path])
            
            # Add filter complex
            cmd.extend([
                '-filter_complex', filter_complex,
                '-map', '[outv]',
                '-map', '[outa]',
                '-c:v', config.VIDEO_CODEC,
                '-preset', config.VIDEO_PRESET,
                '-crf', str(config.VIDEO_CRF),
                '-c:a', config.AUDIO_CODEC,
                '-b:a', config.AUDIO_BITRATE,
                '-movflags', 'faststart',
                '-y',
                output_path
            ])
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0 and os.path.exists(output_path):
                return output_path
            
            if config.DEBUG:
                print(f"FFmpeg stderr: {result.stderr}")
            
            return None
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error in re-encoding merge: {str(e)}")
            return None
    
    def _merge_with_transition(
        self,
        video_paths: List[str],
        output_path: str,
        transition: str,
        duration: float
    ) -> Optional[str]:
        """
        Merge videos with transitions (fade, dissolve)
        
        Args:
            video_paths: List of video paths
            output_path: Output path
            transition: Transition type
            duration: Transition duration
            
        Returns:
            Output path or None
        """
        try:
            # Get duration of each video
            video_durations = []
            for video_path in video_paths:
                probe = ffmpeg.probe(video_path)
                duration_val = float(probe['format']['duration'])
                video_durations.append(duration_val)
            
            # Build complex filter for transitions
            filter_parts = []
            
            # Create transition points
            offset = 0
            for i in range(len(video_paths)):
                if i == 0:
                    filter_parts.append(f"[{i}:v]")
                else:
                    # Calculate transition offset
                    transition_offset = offset - duration
                    
                    if transition == 'fade':
                        filter_parts.append(
                            f"[{i}:v]fade=in:st=0:d={duration}[v{i}];"
                            f"[v{i-1}][v{i}]overlay=enable='between(t,{transition_offset},{offset})'[v{i}out]"
                        )
                    elif transition == 'dissolve':
                        filter_parts.append(
                            f"[v{i-1}][{i}:v]blend=all_expr='A*(1-T/{duration})+B*(T/{duration})':shortest=1[v{i}out]"
                        )
                
                offset += video_durations[i]
            
            # This is complex - for simplicity, fall back to simple merge
            # Full transition implementation requires more complex filter graphs
            return self._merge_with_reencoding(video_paths, output_path)
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error in transition merge: {str(e)}")
            return self._merge_with_reencoding(video_paths, output_path)
    
    def get_combined_duration(self, video_paths: List[str]) -> float:
        """
        Get total duration of all videos combined
        
        Args:
            video_paths: List of video paths
            
        Returns:
            Total duration in seconds
        """
        total_duration = 0.0
        
        for video_path in video_paths:
            try:
                probe = ffmpeg.probe(video_path)
                duration = float(probe['format']['duration'])
                total_duration += duration
            except Exception:
                pass
        
        return total_duration


def merge_videos(
    video_paths: List[str],
    output_path: Optional[str] = None,
    transition: Optional[str] = None
) -> Optional[str]:
    """
    Main function to merge multiple videos
    
    Args:
        video_paths: List of video file paths
        output_path: Output file path (optional)
        transition: Transition type ('fade', 'dissolve', None)
        
    Returns:
        Path to merged video or None if failed
    """
    combiner = VideoCombiner()
    return combiner.merge(video_paths, output_path, transition)


def concatenate_segments(
    segment_paths: List[str],
    output_path: str,
    audio_path: Optional[str] = None,
    audio_start: float = 0.0
) -> Optional[str]:
    """
    Concatenate video segments and optionally add audio
    
    Args:
        segment_paths: List of video segment paths
        output_path: Output file path
        audio_path: Optional audio file to add
        audio_start: Audio start time offset
        
    Returns:
        Path to output video or None if failed
    """
    try:
        combiner = VideoCombiner()
        
        # First merge the segments
        merged = combiner.merge(segment_paths, output_path)
        
        if not merged:
            return None
        
        # If audio provided, add it
        if audio_path and os.path.exists(audio_path):
            temp_output = str(Path(output_path).parent / f"temp_{Path(output_path).name}")
            
            # Get video duration
            probe = ffmpeg.probe(merged)
            video_duration = float(probe['format']['duration'])
            
            # Add audio with proper timing
            cmd = [
                'ffmpeg',
                '-i', merged,
                '-ss', str(audio_start),
                '-t', str(video_duration),
                '-i', audio_path,
                '-c:v', 'copy',
                '-c:a', config.AUDIO_CODEC,
                '-b:a', config.AUDIO_BITRATE,
                '-map', '0:v:0',
                '-map', '1:a:0',
                '-shortest',
                '-y',
                temp_output
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0 and os.path.exists(temp_output):
                # Replace original with audio version
                os.replace(temp_output, output_path)
        
        return output_path
    
    except Exception as e:
        if config.DEBUG:
            print(f"Error concatenating segments: {str(e)}")
        return None


def get_total_duration(video_paths: List[str]) -> float:
    """
    Get total duration of multiple videos
    
    Args:
        video_paths: List of video paths
        
    Returns:
        Total duration in seconds
    """
    combiner = VideoCombiner()
    return combiner.get_combined_duration(video_paths)


================================================================================
FILE: processors/image_overlay.py
================================================================================

"""
Image Overlay Processor - COMPLETE FIX
Overlay images on video with animations
Uses position animations + enable expressions (no fade filters to avoid timing conflicts)
"""

import os
import random
import subprocess
from pathlib import Path
from typing import List, Optional, Tuple, Dict
import ffmpeg

import config
from utils.ffmpeg_helper import get_video_info, get_video_duration, get_video_resolution
from utils.file_manager import FileManager


class ImageOverlayProcessor:
    """Handler for overlaying images on video with animations"""
    
    def __init__(self):
        """Initialize image overlay processor"""
        self.temp_dir = config.TEMP_DIR
        self.temp_dir.mkdir(parents=True, exist_ok=True)
        self.file_manager = FileManager()
    
    def process(
        self,
        video_path: str,
        images_folder: str,
        output_path: str,
        duration_per_image: Optional[float] = None,
        delay_between_images: float = 0.0,
        animation_style: str = 'random',
        animation_duration: float = None
    ) -> Optional[str]:
        """
        Overlay images from folder onto video with animations
        
        Args:
            video_path: Path to background video
            images_folder: Folder containing images
            output_path: Output video path
            duration_per_image: How long each image shows (auto-calculate if None)
            delay_between_images: Gap between images in seconds
            animation_style: Animation type ('slide_bottom', 'slide_left', 'slide_right', 
                           'slide_top', 'fade', 'random')
            animation_duration: Duration of animation in seconds (uses config default if None)
            
        Returns:
            Path to output video or None if failed
        """
        try:
            # Validate inputs
            if not os.path.exists(video_path):
                if config.DEBUG:
                    print(f"Video not found: {video_path}")
                return None
            
            if not os.path.exists(images_folder):
                if config.DEBUG:
                    print(f"Images folder not found: {images_folder}")
                return None
            
            # Load images from folder
            image_paths = self._load_images_from_folder(images_folder)
            
            if not image_paths:
                if config.DEBUG:
                    print("No images found in folder")
                return None
            
            # Get video info
            video_info = get_video_info(video_path)
            if not video_info:
                if config.DEBUG:
                    print("Could not read video info")
                return None
            
            video_duration = video_info['duration']
            video_width = video_info['width']
            video_height = video_info['height']
            
            # Calculate timing
            timing_info = self._calculate_timing(
                num_images=len(image_paths),
                video_duration=video_duration,
                duration_per_image=duration_per_image,
                delay_between_images=delay_between_images
            )
            
            if not timing_info:
                return None
            
            # Use animation duration from config if not provided
            if animation_duration is None:
                animation_duration = config.IMAGE_ANIMATION_DURATION
            
            # Build FFmpeg filter complex
            filter_complex = self._build_filter_complex(
                image_paths=image_paths,
                video_width=video_width,
                video_height=video_height,
                timing_info=timing_info,
                animation_style=animation_style,
                animation_duration=animation_duration
            )
            
            if config.VERBOSE or config.DEBUG:
                print(f"\n=== FILTER COMPLEX ===")
                print(filter_complex)
                print(f"======================\n")
            
            # Execute FFmpeg command
            success = self._execute_ffmpeg(
                video_path=video_path,
                image_paths=image_paths,
                filter_complex=filter_complex,
                output_path=output_path
            )
            
            if success and os.path.exists(output_path):
                return output_path
            
            return None
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error in image overlay process: {str(e)}")
                import traceback
                traceback.print_exc()
            return None
    
    def _load_images_from_folder(self, folder_path: str) -> List[str]:
        """
        Load all valid images from folder (sorted alphabetically)
        
        Args:
            folder_path: Path to folder containing images
            
        Returns:
            List of image file paths
        """
        image_paths = []
        
        try:
            folder = Path(folder_path)
            
            # Get all files
            for item in sorted(folder.iterdir()):
                if item.is_file():
                    ext = item.suffix.lower()
                    if ext in config.IMAGE_EXTENSIONS:
                        image_paths.append(str(item))
            
            if config.VERBOSE:
                print(f"Found {len(image_paths)} images in folder")
            
            return image_paths
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error loading images: {str(e)}")
            return []
    
    def _calculate_timing(
        self,
        num_images: int,
        video_duration: float,
        duration_per_image: Optional[float],
        delay_between_images: float
    ) -> Optional[Dict]:
        """
        Calculate timing for each image
        
        Args:
            num_images: Number of images
            video_duration: Total video duration
            duration_per_image: Duration each image shows (None for auto)
            delay_between_images: Gap between images
            
        Returns:
            Dict with timing info or None if invalid
        """
        try:
            # Auto-calculate duration if not provided
            if duration_per_image is None:
                # Calculate based on video duration and number of images
                # Account for delays AFTER each image (except the last one)
                total_delay_time = delay_between_images * (num_images - 1) if num_images > 1 else 0
                available_time = video_duration - total_delay_time
                
                if available_time <= 0:
                    if config.VERBOSE:
                        print("Video too short for delays, removing delays")
                    # Fallback: no delays, just fit images
                    delay_between_images = 0
                    available_time = video_duration
                
                duration_per_image = available_time / num_images
                
                # Ensure minimum duration
                if duration_per_image < 1.0:
                    duration_per_image = 1.0
                    if config.VERBOSE:
                        print(f"Warning: Setting minimum duration of 1.0s per image")
            
            # Calculate start and end times for each image
            start_times = []
            end_times = []
            current_time = 0.0
            
            for i in range(num_images):
                start_times.append(current_time)
                current_time += duration_per_image
                end_times.append(current_time)
                
                # Add delay after each image except the last one
                if i < num_images - 1:
                    current_time += delay_between_images
            
            # Check if we exceed video duration
            total_time = end_times[-1]
            
            if total_time > video_duration:
                # Scale everything down proportionally
                scale_factor = video_duration / total_time
                
                if config.VERBOSE:
                    print(f"Timeline exceeds video duration, scaling by {scale_factor:.3f}")
                
                start_times = [t * scale_factor for t in start_times]
                end_times = [t * scale_factor for t in end_times]
                duration_per_image = duration_per_image * scale_factor
                total_time = video_duration
            
            if config.VERBOSE:
                print(f"\n=== TIMING INFO ===")
                print(f"Number of images: {num_images}")
                print(f"Duration per image: {duration_per_image:.2f}s")
                print(f"Delay between images: {delay_between_images:.2f}s")
                print(f"Total timeline: {total_time:.2f}s")
                for i in range(num_images):
                    print(f"  Image {i+1}: {start_times[i]:.2f}s - {end_times[i]:.2f}s")
                print(f"===================\n")
            
            return {
                'duration_per_image': duration_per_image,
                'start_times': start_times,
                'end_times': end_times,
                'num_images': num_images,
                'total_duration': total_time,
                'delay_between_images': delay_between_images,
            }
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error calculating timing: {str(e)}")
            return None
    
    def _calculate_image_dimensions(
        self,
        image_path: str,
        video_width: int,
        video_height: int
    ) -> Tuple[int, int]:
        """
        Calculate target dimensions for image (resize only if exceeds 85% of frame)
        Maintains aspect ratio and adds 15% padding from edges
        
        Args:
            image_path: Path to image
            video_width: Video width
            video_height: Video height
            
        Returns:
            Tuple of (target_width, target_height)
        """
        try:
            # Get image dimensions using ffprobe
            probe = ffmpeg.probe(image_path)
            
            # Find video stream (images are treated as video by ffprobe)
            img_stream = next(
                (stream for stream in probe['streams'] if stream['codec_type'] == 'video'),
                None
            )
            
            if not img_stream:
                # Fallback to max allowed size
                max_width = int(video_width * config.IMAGE_MAX_SIZE_RATIO)
                max_height = int(video_height * config.IMAGE_MAX_SIZE_RATIO)
                return max_width, max_height
            
            img_width = int(img_stream['width'])
            img_height = int(img_stream['height'])
            
            # Calculate max allowed dimensions (85% of frame)
            max_width = int(video_width * config.IMAGE_MAX_SIZE_RATIO)
            max_height = int(video_height * config.IMAGE_MAX_SIZE_RATIO)
            
            # Check if image exceeds max dimensions
            if img_width <= max_width and img_height <= max_height:
                # Image fits within bounds - no resize needed
                return img_width, img_height
            
            # Image is too large - resize maintaining aspect ratio
            img_aspect = img_width / img_height
            max_aspect = max_width / max_height
            
            if img_aspect > max_aspect:
                # Image is wider - fit to max width
                target_width = max_width
                target_height = int(max_width / img_aspect)
            else:
                # Image is taller - fit to max height
                target_height = max_height
                target_width = int(max_height * img_aspect)
            
            # Ensure dimensions are even (required by some codecs)
            target_width = target_width - (target_width % 2)
            target_height = target_height - (target_height % 2)
            
            return target_width, target_height
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error calculating dimensions for {image_path}: {str(e)}")
            
            # Fallback
            max_width = int(video_width * config.IMAGE_MAX_SIZE_RATIO)
            max_height = int(video_height * config.IMAGE_MAX_SIZE_RATIO)
            return max_width, max_height
    
    def _build_filter_complex(
        self,
        image_paths: List[str],
        video_width: int,
        video_height: int,
        timing_info: Dict,
        animation_style: str,
        animation_duration: float
    ) -> str:
        """
        Build FFmpeg filter_complex for all image overlays
        Uses ONLY position animations and enable expressions (no fade filters)
        
        Args:
            image_paths: List of image paths
            video_width: Video width
            video_height: Video height
            timing_info: Timing information dict
            animation_style: Animation style
            animation_duration: Animation duration
            
        Returns:
            filter_complex string
        """
        filters = []
        
        start_times = timing_info['start_times']
        end_times = timing_info['end_times']
        
        # STEP 1: Scale and prepare all images
        for i, img_path in enumerate(image_paths):
            # Calculate dimensions
            img_width, img_height = self._calculate_image_dimensions(
                img_path,
                video_width,
                video_height
            )
            
            # Scale and add alpha channel for transparency support
            # format=yuva420p adds alpha channel
            scale_filter = (
                f"[{i + 1}:v]"
                f"scale={img_width}:{img_height}:force_original_aspect_ratio=decrease,"
                f"format=yuva420p"
                f"[img{i}]"
            )
            filters.append(scale_filter)
        
        # STEP 2: Build overlay chain with position-based animations
        current_layer = "[0:v]"
        
        for i, img_path in enumerate(image_paths):
            img_width, img_height = self._calculate_image_dimensions(
                img_path,
                video_width,
                video_height
            )
            
            start_time = start_times[i]
            end_time = end_times[i]
            actual_duration = end_time - start_time
            
            # Calculate center position
            center_x = (video_width - img_width) // 2
            center_y = (video_height - img_height) // 2
            
            # Choose animation style for this image
            current_animation = animation_style
            if animation_style == 'random':
                current_animation = random.choice([
                    'slide_bottom', 'slide_left', 'slide_right', 'slide_top', 'fade'
                ])
            
            # Animation timing
            anim_duration = min(animation_duration, actual_duration * 0.25)  # Max 25% of duration
            exit_start_time = end_time - anim_duration
            
            # Build position expressions based on animation type
            x_expr, y_expr = self._build_animation_expressions(
                animation_type=current_animation,
                video_width=video_width,
                video_height=video_height,
                img_width=img_width,
                img_height=img_height,
                center_x=center_x,
                center_y=center_y,
                start_time=start_time,
                end_time=end_time,
                anim_duration=anim_duration,
                exit_start_time=exit_start_time
            )
            
            # Enable expression - show image only during its time window
            enable_expr = f"between(t,{start_time},{end_time})"
            
            # Create overlay
            if i == len(image_paths) - 1:
                # Last overlay - output to final
                overlay_cmd = (
                    f"{current_layer}[img{i}]overlay="
                    f"x='{x_expr}':y='{y_expr}':enable='{enable_expr}'"
                )
            else:
                # Intermediate overlay
                overlay_cmd = (
                    f"{current_layer}[img{i}]overlay="
                    f"x='{x_expr}':y='{y_expr}':enable='{enable_expr}'[tmp{i}]"
                )
                current_layer = f"[tmp{i}]"
            
            filters.append(overlay_cmd)
        
        # Join all filters with semicolons
        filter_complex = ";".join(filters)
        
        return filter_complex
    
    def _build_animation_expressions(
        self,
        animation_type: str,
        video_width: int,
        video_height: int,
        img_width: int,
        img_height: int,
        center_x: int,
        center_y: int,
        start_time: float,
        end_time: float,
        anim_duration: float,
        exit_start_time: float
    ) -> Tuple[str, str]:
        """
        Build x and y position expressions for animation
        
        Returns:
            Tuple of (x_expr, y_expr)
        """
        
        if animation_type == 'slide_bottom':
            # Enter from bottom, exit to bottom
            off_screen_y = video_height + 100  # Start below screen
            
            x_expr = str(center_x)
            y_expr = (
                f"if(lt(t,{start_time}),{off_screen_y},"  # Before start: off-screen
                f"if(lt(t,{start_time + anim_duration}),"  # Entry animation
                f"{off_screen_y}-(({off_screen_y}-{center_y})*(t-{start_time})/{anim_duration}),"
                f"if(lt(t,{exit_start_time}),{center_y},"  # Static at center
                f"{center_y}+(({off_screen_y}-{center_y})*(t-{exit_start_time})/{anim_duration})"  # Exit animation
                f")))"
            )
        
        elif animation_type == 'slide_top':
            # Enter from top, exit to top
            off_screen_y = -img_height - 100  # Start above screen
            
            x_expr = str(center_x)
            y_expr = (
                f"if(lt(t,{start_time}),{off_screen_y},"
                f"if(lt(t,{start_time + anim_duration}),"
                f"{off_screen_y}+(({center_y}-{off_screen_y})*(t-{start_time})/{anim_duration}),"
                f"if(lt(t,{exit_start_time}),{center_y},"
                f"{center_y}-(({center_y}-{off_screen_y})*(t-{exit_start_time})/{anim_duration})"
                f")))"
            )
        
        elif animation_type == 'slide_left':
            # Enter from left, exit to left
            off_screen_x = -img_width - 100  # Start left of screen
            
            y_expr = str(center_y)
            x_expr = (
                f"if(lt(t,{start_time}),{off_screen_x},"
                f"if(lt(t,{start_time + anim_duration}),"
                f"{off_screen_x}+(({center_x}-{off_screen_x})*(t-{start_time})/{anim_duration}),"
                f"if(lt(t,{exit_start_time}),{center_x},"
                f"{center_x}-(({center_x}-{off_screen_x})*(t-{exit_start_time})/{anim_duration})"
                f")))"
            )
        
        elif animation_type == 'slide_right':
            # Enter from right, exit to right
            off_screen_x = video_width + 100  # Start right of screen
            
            y_expr = str(center_y)
            x_expr = (
                f"if(lt(t,{start_time}),{off_screen_x},"
                f"if(lt(t,{start_time + anim_duration}),"
                f"{off_screen_x}-(({off_screen_x}-{center_x})*(t-{start_time})/{anim_duration}),"
                f"if(lt(t,{exit_start_time}),{center_x},"
                f"{center_x}+(({off_screen_x}-{center_x})*(t-{exit_start_time})/{anim_duration})"
                f")))"
            )
        
        else:  # 'fade' - no position animation, just static centered position
            # The enable expression handles visibility
            x_expr = str(center_x)
            y_expr = str(center_y)
        
        return x_expr, y_expr
    
    def _execute_ffmpeg(
        self,
        video_path: str,
        image_paths: List[str],
        filter_complex: str,
        output_path: str
    ) -> bool:
        """
        Execute FFmpeg command to create overlay video
        
        Args:
            video_path: Background video path
            image_paths: List of image paths
            filter_complex: Filter complex string
            output_path: Output video path
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Build FFmpeg command
            cmd = ['ffmpeg']
            
            # Add video input
            cmd.extend(['-i', video_path])
            
            # Add all image inputs with loop
            for img_path in image_paths:
                cmd.extend(['-loop', '1', '-i', img_path])
            
            # Add filter complex
            cmd.extend(['-filter_complex', filter_complex])
            
            # Output settings
            cmd.extend([
                '-c:v', config.VIDEO_CODEC,
                '-preset', config.VIDEO_PRESET,
                '-crf', str(config.VIDEO_CRF),
                '-c:a', 'copy',  # Copy audio stream
                '-movflags', 'faststart',
                '-threads', str(config.FFMPEG_THREADS),
                '-shortest',  # Stop when shortest input ends (the video)
                '-y',  # Overwrite output
                output_path
            ])
            
            if config.VERBOSE or config.DEBUG:
                print(f"\n=== FFMPEG COMMAND ===")
                print(' '.join(cmd))
                print(f"======================\n")
            
            # Execute
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                if config.DEBUG:
                    print(f"FFmpeg error (return code {result.returncode}):")
                    print(f"STDERR: {result.stderr}")
                    print(f"STDOUT: {result.stdout}")
                return False
            
            if config.VERBOSE:
                print(f"✓ Video created successfully: {output_path}")
            
            return True
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error executing FFmpeg: {str(e)}")
                import traceback
                traceback.print_exc()
            return False
    
    def preview_timing(
        self,
        num_images: int,
        video_duration: float,
        duration_per_image: Optional[float] = None,
        delay_between_images: float = 0.0
    ) -> Optional[Dict]:
        """
        Preview timing configuration without processing
        
        Args:
            num_images: Number of images
            video_duration: Video duration
            duration_per_image: Duration per image (None for auto)
            delay_between_images: Delay between images
            
        Returns:
            Dict with timing preview
        """
        timing_info = self._calculate_timing(
            num_images=num_images,
            video_duration=video_duration,
            duration_per_image=duration_per_image,
            delay_between_images=delay_between_images
        )
        
        if not timing_info:
            return None
        
        # Add readable format
        preview = {
            'num_images': num_images,
            'video_duration': video_duration,
            'duration_per_image': timing_info['duration_per_image'],
            'delay_between_images': timing_info.get('delay_between_images', delay_between_images),
            'total_duration': timing_info['total_duration'],
            'timeline': []
        }
        
        for i in range(len(timing_info['start_times'])):
            start_time = timing_info['start_times'][i]
            end_time = timing_info['end_times'][i]
            actual_duration = end_time - start_time
            
            preview['timeline'].append({
                'image_index': i + 1,
                'start': f"{start_time:.2f}s",
                'end': f"{end_time:.2f}s",
                'duration': f"{actual_duration:.2f}s"
            })
        
        return preview


# ============================================================================
# MODULE-LEVEL CONVENIENCE FUNCTIONS
# ============================================================================

def overlay_images_on_video(
    video_path: str,
    images_folder: str,
    output_path: str,
    duration_per_image: Optional[float] = None,
    delay_between_images: float = 0.0,
    animation_style: str = 'random'
) -> Optional[str]:
    """
    Main function to overlay images on video with animations
    
    Args:
        video_path: Path to background video
        images_folder: Folder containing images
        output_path: Output video path
        duration_per_image: Duration each image shows (auto if None)
        delay_between_images: Gap between images in seconds
        animation_style: Animation type
        
    Returns:
        Path to output video or None if failed
    """
    processor = ImageOverlayProcessor()
    return processor.process(
        video_path=video_path,
        images_folder=images_folder,
        output_path=output_path,
        duration_per_image=duration_per_image,
        delay_between_images=delay_between_images,
        animation_style=animation_style
    )


def preview_image_timing(
    num_images: int,
    video_duration: float,
    duration_per_image: Optional[float] = None,
    delay_between_images: float = 0.0
) -> Optional[Dict]:
    """
    Preview timing configuration for images
    """
    processor = ImageOverlayProcessor()
    return processor.preview_timing(
        num_images=num_images,
        video_duration=video_duration,
        duration_per_image=duration_per_image,
        delay_between_images=delay_between_images
    )


def get_images_from_folder(folder_path: str) -> List[str]:
    """
    Get list of images from folder
    """
    processor = ImageOverlayProcessor()
    return processor._load_images_from_folder(folder_path)


def validate_overlay_inputs(
    video_path: str,
    images_folder: str,
    duration_per_image: Optional[float] = None
) -> Tuple[bool, str]:
    """
    Validate inputs for image overlay
    """
    # Check video
    if not os.path.exists(video_path):
        return False, "Video file not found"
    
    video_info = get_video_info(video_path)
    if not video_info:
        return False, "Invalid video file"
    
    # Check images folder
    if not os.path.exists(images_folder):
        return False, "Images folder not found"
    
    if not os.path.isdir(images_folder):
        return False, "Images path is not a folder"
    
    processor = ImageOverlayProcessor()
    images = processor._load_images_from_folder(images_folder)
    
    if not images:
        return False, "No valid images found in folder"
    
    # Check duration
    if duration_per_image is not None:
        if duration_per_image <= 0:
            return False, "Duration per image must be positive"
        
        if duration_per_image < 0.1:
            return False, "Duration per image too short (minimum 0.1s)"
    
    return True, f"Valid: {len(images)} images, video duration: {video_info['duration']:.2f}s"


================================================================================
FILE: processors/normalizer.py
================================================================================

"""
Video Normalizer - Normalize videos to consistent format
Handles fps, codec, resolution, bitrate normalization and cropping
"""

import os
import subprocess
import json
from pathlib import Path
from typing import Dict, Optional, Tuple, List
import ffmpeg

import config


class VideoNormalizer:
    """Handler for video normalization using FFmpeg"""
    
    def __init__(self):
        """Initialize video normalizer"""
        self.temp_dir = config.NORMALIZED_DIR
        self.temp_dir.mkdir(parents=True, exist_ok=True)
    
    def normalize(
        self,
        video_path: str,
        target_resolution: Tuple[int, int] = (1080, 1920),
        target_fps: int = 30,
        target_codec: str = 'libx264',
        target_bitrate: str = '5M',
        crop_mode: str = 'center',
        output_path: Optional[str] = None
    ) -> Optional[str]:
        """
        Normalize video to target specifications
        
        Args:
            video_path: Input video path
            target_resolution: Target (width, height)
            target_fps: Target frames per second
            target_codec: Target video codec
            target_bitrate: Target video bitrate
            crop_mode: How to handle aspect ratio ('center', 'fit', 'stretch')
            output_path: Custom output path (optional)
            
        Returns:
            Path to normalized video or None if failed
        """
        try:
            if not os.path.exists(video_path):
                if config.DEBUG:
                    print(f"Video file not found: {video_path}")
                return None
            
            # Get input video info
            video_info = self._get_video_info(video_path)
            if not video_info:
                return None
            
            # Determine output path
            if output_path is None:
                input_name = Path(video_path).stem
                output_path = str(self.temp_dir / f"{input_name}_normalized.mp4")
            
            # Build FFmpeg filter chain
            filter_chain = self._build_filter_chain(
                video_info,
                target_resolution,
                target_fps,
                crop_mode
            )
            
            # Build FFmpeg command
            success = self._run_ffmpeg_normalize(
                video_path,
                output_path,
                filter_chain,
                target_codec,
                target_bitrate
            )
            
            if success and os.path.exists(output_path):
                return output_path
            
            return None
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error normalizing video: {str(e)}")
            return None
    
    def _get_video_info(self, video_path: str) -> Optional[Dict]:
        """
        Get video information using ffprobe
        
        Args:
            video_path: Path to video file
            
        Returns:
            Dict with video info or None
        """
        try:
            probe = ffmpeg.probe(video_path)
            
            # Find video stream
            video_stream = next(
                (stream for stream in probe['streams'] if stream['codec_type'] == 'video'),
                None
            )
            
            if not video_stream:
                return None
            
            # Extract info
            width = int(video_stream['width'])
            height = int(video_stream['height'])
            
            # Get fps
            fps_str = video_stream.get('r_frame_rate', '30/1')
            fps_parts = fps_str.split('/')
            fps = int(fps_parts[0]) / int(fps_parts[1]) if len(fps_parts) == 2 else 30
            
            # Get duration
            duration = float(probe['format'].get('duration', 0))
            
            # Get codec
            codec = video_stream.get('codec_name', 'unknown')
            
            # Get bitrate
            bitrate = probe['format'].get('bit_rate', '0')
            
            return {
                'width': width,
                'height': height,
                'fps': fps,
                'duration': duration,
                'codec': codec,
                'bitrate': bitrate,
                'aspect_ratio': width / height if height > 0 else 16/9,
            }
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error getting video info: {str(e)}")
            return None
    
    def _build_filter_chain(
        self,
        video_info: Dict,
        target_resolution: Tuple[int, int],
        target_fps: int,
        crop_mode: str
    ) -> str:
        """
        Build FFmpeg filter chain for normalization
        
        Args:
            video_info: Input video information
            target_resolution: Target (width, height)
            target_fps: Target fps
            crop_mode: Cropping mode
            
        Returns:
            FFmpeg filter string
        """
        filters = []
        
        target_width, target_height = target_resolution
        input_width = video_info['width']
        input_height = video_info['height']
        
        target_aspect = target_width / target_height
        input_aspect = input_width / input_height
        
        # Handle resolution and aspect ratio
        if crop_mode == 'center':
            # Crop to target aspect ratio, then scale
            if input_aspect > target_aspect:
                # Input is wider - crop width
                crop_width = int(input_height * target_aspect)
                crop_height = input_height
                crop_x = (input_width - crop_width) // 2
                crop_y = 0
            else:
                # Input is taller - crop height
                crop_width = input_width
                crop_height = int(input_width / target_aspect)
                crop_x = 0
                crop_y = (input_height - crop_height) // 2
            
            # Add crop filter
            filters.append(f"crop={crop_width}:{crop_height}:{crop_x}:{crop_y}")
            
            # Add scale filter
            filters.append(f"scale={target_width}:{target_height}")
        
        elif crop_mode == 'fit':
            # Scale to fit within target resolution (may have black bars)
            filters.append(
                f"scale={target_width}:{target_height}:force_original_aspect_ratio=decrease,"
                f"pad={target_width}:{target_height}:(ow-iw)/2:(oh-ih)/2"
            )
        
        elif crop_mode == 'stretch':
            # Just scale (ignore aspect ratio)
            filters.append(f"scale={target_width}:{target_height}")
        
        # Add fps filter if needed
        if abs(video_info['fps'] - target_fps) > 0.1:
            filters.append(f"fps={target_fps}")
        
        # Optional: Add quality enhancement filters
        # Denoise slightly
        # filters.append("hqdn3d=1.5:1.5:6:6")
        
        return ','.join(filters)
    
    def _run_ffmpeg_normalize(
        self,
        input_path: str,
        output_path: str,
        filter_chain: str,
        codec: str,
        bitrate: str
    ) -> bool:
        """
        Run FFmpeg normalization command
        
        Args:
            input_path: Input video path
            output_path: Output video path
            filter_chain: FFmpeg filter string
            codec: Video codec
            bitrate: Video bitrate
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Build FFmpeg command using ffmpeg-python
            stream = ffmpeg.input(input_path)
            
            # Apply video filters
            stream = ffmpeg.filter(stream, 'scale', filter_chain) if not filter_chain else stream
            
            # If we have a complex filter chain, use it directly
            if filter_chain:
                stream = stream.filter('null')  # Placeholder, we'll use -vf directly
            
            # Output with settings
            stream = ffmpeg.output(
                stream,
                output_path,
                vcodec=codec,
                video_bitrate=bitrate,
                acodec=config.AUDIO_CODEC,
                audio_bitrate=config.AUDIO_BITRATE,
                preset=config.VIDEO_PRESET,
                crf=config.VIDEO_CRF,
                movflags='faststart',
                **{'threads': config.FFMPEG_THREADS}
            )
            
            # Run with filter chain if provided
            if filter_chain:
                # Use subprocess for complex filters
                cmd = [
                    'ffmpeg',
                    '-i', input_path,
                    '-vf', filter_chain,
                    '-c:v', codec,
                    '-b:v', bitrate,
                    '-c:a', config.AUDIO_CODEC,
                    '-b:a', config.AUDIO_BITRATE,
                    '-preset', config.VIDEO_PRESET,
                    '-crf', str(config.VIDEO_CRF),
                    '-movflags', 'faststart',
                    '-threads', str(config.FFMPEG_THREADS),
                    '-y',  # Overwrite output
                    output_path
                ]
                
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True
                )
                
                return result.returncode == 0
            else:
                # Use ffmpeg-python
                ffmpeg.run(stream, overwrite_output=True, quiet=not config.VERBOSE)
                return True
        
        except Exception as e:
            if config.DEBUG:
                print(f"FFmpeg error: {str(e)}")
            return False
    
    def get_video_stats(self, video_path: str) -> Optional[Dict]:
        """
        Get detailed video statistics
        
        Args:
            video_path: Path to video
            
        Returns:
            Dict with video stats
        """
        return self._get_video_info(video_path)
    
    def needs_normalization(
        self,
        video_path: str,
        target_resolution: Tuple[int, int] = (1080, 1920),
        target_fps: int = 30
    ) -> bool:
        """
        Check if video needs normalization
        
        Args:
            video_path: Path to video
            target_resolution: Target resolution
            target_fps: Target fps
            
        Returns:
            True if normalization needed
        """
        info = self._get_video_info(video_path)
        
        if not info:
            return True
        
        # Check resolution
        if info['width'] != target_resolution[0] or info['height'] != target_resolution[1]:
            return True
        
        # Check fps (with tolerance)
        if abs(info['fps'] - target_fps) > 1:
            return True
        
        # Check codec
        if info['codec'] != 'h264':
            return True
        
        return False


def normalize_video(
    video_path: str,
    target_resolution: Tuple[int, int] = None,
    target_fps: int = None,
    crop_mode: str = 'center',
    output_path: Optional[str] = None
) -> Optional[str]:
    """
    Main function to normalize a video
    
    Args:
        video_path: Input video path
        target_resolution: Target (width, height) - defaults to reels size
        target_fps: Target fps - defaults to 30
        crop_mode: How to handle aspect ratio ('center', 'fit', 'stretch')
        output_path: Custom output path
        
    Returns:
        Path to normalized video or None if failed
    """
    if target_resolution is None:
        target_resolution = config.RESOLUTIONS['reels']
    
    if target_fps is None:
        target_fps = config.TARGET_FPS
    
    normalizer = VideoNormalizer()
    
    return normalizer.normalize(
        video_path=video_path,
        target_resolution=target_resolution,
        target_fps=target_fps,
        target_codec=config.VIDEO_CODEC,
        target_bitrate=config.TARGET_BITRATE,
        crop_mode=crop_mode,
        output_path=output_path
    )


def batch_normalize(
    video_paths: List[str],
    target_resolution: Tuple[int, int] = None,
    target_fps: int = None,
    crop_mode: str = 'center'
) -> List[str]:
    """
    Normalize multiple videos
    
    Args:
        video_paths: List of video paths
        target_resolution: Target resolution
        target_fps: Target fps
        crop_mode: Cropping mode
        
    Returns:
        List of normalized video paths
    """
    if target_resolution is None:
        target_resolution = config.RESOLUTIONS['reels']
    
    if target_fps is None:
        target_fps = config.TARGET_FPS
    
    normalizer = VideoNormalizer()
    normalized_videos = []
    
    for video_path in video_paths:
        normalized = normalizer.normalize(
            video_path=video_path,
            target_resolution=target_resolution,
            target_fps=target_fps,
            crop_mode=crop_mode
        )
        
        if normalized:
            normalized_videos.append(normalized)
    
    return normalized_videos


def check_ffmpeg_installed() -> bool:
    """
    Check if FFmpeg is installed
    
    Returns:
        True if installed, False otherwise
    """
    try:
        subprocess.run(
            ['ffmpeg', '-version'],
            capture_output=True,
            check=True
        )
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


================================================================================
FILE: processors/video_cutter.py
================================================================================

"""
Video Cutter - Extract segments and merge with audio
Handles video cutting at specified timestamps
"""

import os
import random
import subprocess
import tempfile
from pathlib import Path
from typing import List, Optional, Tuple, Dict
import ffmpeg

import config


class VideoCutter:
    """Handler for cutting videos into segments"""
    
    def __init__(self):
        """Initialize video cutter"""
        self.temp_dir = config.TEMP_DIR
        self.temp_dir.mkdir(parents=True, exist_ok=True)
    
    def extract_segment(
        self,
        video_path: str,
        start_time: float,
        duration: float,
        output_path: Optional[str] = None
    ) -> Optional[str]:
        """
        Extract a segment from video
        
        Args:
            video_path: Input video path
            start_time: Start time in seconds
            duration: Duration in seconds
            output_path: Output path (optional)
            
        Returns:
            Path to extracted segment or None
        """
        try:
            if not os.path.exists(video_path):
                return None
            
            # Generate output path if not provided
            if output_path is None:
                output_path = str(
                    self.temp_dir / f"segment_{start_time:.2f}_{duration:.2f}.mp4"
                )
            
            # Extract segment using FFmpeg
            cmd = [
                'ffmpeg',
                '-ss', str(start_time),
                '-i', video_path,
                '-t', str(duration),
                '-c:v', config.VIDEO_CODEC,
                '-preset', 'ultrafast',  # Fast for segments
                '-crf', str(config.VIDEO_CRF),
                '-c:a', config.AUDIO_CODEC,
                '-b:a', config.AUDIO_BITRATE,
                '-avoid_negative_ts', 'make_zero',
                '-y',
                output_path
            ]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0 and os.path.exists(output_path):
                return output_path
            
            return None
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error extracting segment: {str(e)}")
            return None
    
    def create_segments_from_timestamps(
        self,
        video_path: str,
        timestamps: List[float],
        audio_duration: float,
        order: str = 'sequential'
    ) -> List[str]:
        """
        Create video segments based on timestamps
        
        Args:
            video_path: Input video path
            timestamps: List of cut points in seconds
            audio_duration: Total audio duration to match
            order: 'sequential' or 'random'
            
        Returns:
            List of segment file paths
        """
        try:
            # Get video info
            probe = ffmpeg.probe(video_path)
            video_duration = float(probe['format']['duration'])
            
            # Calculate segment durations based on timestamps
            segment_durations = []
            for i in range(len(timestamps) - 1):
                duration = timestamps[i + 1] - timestamps[i]
                if duration > config.MIN_SEGMENT_DURATION:
                    segment_durations.append(duration)
            
            # If not enough segments, add remaining time
            if segment_durations:
                total_segments_duration = sum(segment_durations)
                if total_segments_duration < audio_duration:
                    # Add one more segment
                    remaining = audio_duration - total_segments_duration
                    if remaining > config.MIN_SEGMENT_DURATION:
                        segment_durations.append(remaining)
            else:
                # No valid segments, use entire video
                segment_durations = [min(audio_duration, video_duration)]
            
            # Generate segments
            segments = []
            current_video_time = 0.0
            
            for i, seg_duration in enumerate(segment_durations):
                # Ensure we don't exceed video duration
                if current_video_time + seg_duration > video_duration:
                    # Loop back to start
                    current_video_time = 0.0
                
                # Extract segment
                segment_path = self.extract_segment(
                    video_path,
                    current_video_time,
                    seg_duration,
                    output_path=str(self.temp_dir / f"segment_{i:04d}.mp4")
                )
                
                if segment_path:
                    segments.append(segment_path)
                
                # Move to next position
                if order == 'sequential':
                    current_video_time += seg_duration
                else:  # random
                    # Pick random position in video
                    max_start = max(0, video_duration - seg_duration)
                    current_video_time = random.uniform(0, max_start)
            
            return segments
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error creating segments: {str(e)}")
            return []
    
    def merge_segments_with_audio(
        self,
        segment_paths: List[str],
        audio_path: str,
        audio_start: float,
        audio_end: float,
        output_path: str
    ) -> Optional[str]:
        """
        Merge video segments and overlay audio
        
        Args:
            segment_paths: List of video segment paths
            audio_path: Path to audio file
            audio_start: Audio start time
            audio_end: Audio end time
            output_path: Output file path
            
        Returns:
            Path to output video or None
        """
        try:
            if not segment_paths:
                return None
            
            # Create concat file
            concat_file = self.temp_dir / "segments_concat.txt"
            
            with open(concat_file, 'w') as f:
                for segment_path in segment_paths:
                    abs_path = os.path.abspath(segment_path)
                    f.write(f"file '{abs_path}'\n")
            
            # First, concatenate video segments without audio
            temp_video = str(self.temp_dir / "temp_concat.mp4")
            
            cmd_concat = [
                'ffmpeg',
                '-f', 'concat',
                '-safe', '0',
                '-i', str(concat_file),
                '-c', 'copy',
                '-y',
                temp_video
            ]
            
            result = subprocess.run(cmd_concat, capture_output=True, text=True)
            
            if result.returncode != 0 or not os.path.exists(temp_video):
                # Try with re-encoding
                cmd_concat = [
                    'ffmpeg',
                    '-f', 'concat',
                    '-safe', '0',
                    '-i', str(concat_file),
                    '-c:v', config.VIDEO_CODEC,
                    '-preset', config.VIDEO_PRESET,
                    '-crf', str(config.VIDEO_CRF),
                    '-y',
                    temp_video
                ]
                
                result = subprocess.run(cmd_concat, capture_output=True, text=True)
                
                if result.returncode != 0:
                    return None
            
            # Now add audio
            audio_duration = audio_end - audio_start
            
            cmd_audio = [
                'ffmpeg',
                '-i', temp_video,
                '-ss', str(audio_start),
                '-t', str(audio_duration),
                '-i', audio_path,
                '-c:v', 'copy',
                '-c:a', config.AUDIO_CODEC,
                '-b:a', config.AUDIO_BITRATE,
                '-map', '0:v:0',
                '-map', '1:a:0',
                '-shortest',
                '-movflags', 'faststart',
                '-y',
                output_path
            ]
            
            result = subprocess.run(cmd_audio, capture_output=True, text=True)
            
            # Cleanup
            if concat_file.exists():
                concat_file.unlink()
            if os.path.exists(temp_video):
                os.unlink(temp_video)
            
            if result.returncode == 0 and os.path.exists(output_path):
                return output_path
            
            return None
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error merging segments with audio: {str(e)}")
            return None
    
    def cleanup_segments(self, segment_paths: List[str]) -> None:
        """
        Clean up temporary segment files
        
        Args:
            segment_paths: List of segment paths to delete
        """
        for segment_path in segment_paths:
            try:
                if os.path.exists(segment_path):
                    os.unlink(segment_path)
            except Exception as e:
                if config.DEBUG:
                    print(f"Could not delete {segment_path}: {str(e)}")


def create_segments(
    video_path: str,
    cut_points: List[float],
    order: str,
    audio_duration: float
) -> List[str]:
    """
    Create video segments from cut points
    
    Args:
        video_path: Input video path
        cut_points: List of timestamps to cut at
        order: 'sequential' or 'random'
        audio_duration: Target audio duration
        
    Returns:
        List of segment file paths
    """
    cutter = VideoCutter()
    return cutter.create_segments_from_timestamps(
        video_path,
        cut_points,
        audio_duration,
        order
    )


def merge_with_audio(
    segments: List[str],
    audio_path: str,
    audio_start: float,
    audio_end: float,
    output_path: str
) -> Optional[str]:
    """
    Merge segments with audio track
    
    Args:
        segments: List of video segment paths
        audio_path: Path to audio file
        audio_start: Audio start time in seconds
        audio_end: Audio end time in seconds
        output_path: Output file path
        
    Returns:
        Path to final video or None
    """
    cutter = VideoCutter()
    return cutter.merge_segments_with_audio(
        segments,
        audio_path,
        audio_start,
        audio_end,
        output_path
    )


def extract_segment(
    video_path: str,
    start_time: float,
    duration: float,
    output_path: Optional[str] = None
) -> Optional[str]:
    """
    Extract single segment from video
    
    Args:
        video_path: Input video path
        start_time: Start time in seconds
        duration: Duration in seconds
        output_path: Output path (optional)
        
    Returns:
        Path to extracted segment or None
    """
    cutter = VideoCutter()
    return cutter.extract_segment(video_path, start_time, duration, output_path)


def cleanup_temp_segments(segment_paths: List[str]) -> None:
    """
    Clean up temporary segment files
    
    Args:
        segment_paths: List of segment paths to delete
    """
    cutter = VideoCutter()
    cutter.cleanup_segments(segment_paths)


================================================================================
FILE: utils/__init__.py
================================================================================

"""
Utils module for Better Reel Generator
Provides utility functions for FFmpeg, file management, and validation
"""

from .ffmpeg_helper import (
    check_ffmpeg,
    get_video_info,
    get_audio_duration,
    get_video_duration,
    extract_audio_from_video,
    get_video_resolution,
    get_video_fps,
    get_video_codec,
    convert_video_format,
)

from .file_manager import (
    FileManager,
    create_temp_dir,
    cleanup_temp_files,
    get_file_size,
    get_file_extension,
    is_video_file,
    is_audio_file,
    ensure_dir_exists,
)

from .validators import (
    is_valid_url,
    is_valid_video,
    is_valid_audio,
    detect_source,
    validate_file_size,
    validate_video_duration,
)

__all__ = [
    # FFmpeg Helper
    'check_ffmpeg',
    'get_video_info',
    'get_audio_duration',
    'get_video_duration',
    'extract_audio_from_video',
    'get_video_resolution',
    'get_video_fps',
    'get_video_codec',
    'convert_video_format',
    
    # File Manager
    'FileManager',
    'create_temp_dir',
    'cleanup_temp_files',
    'get_file_size',
    'get_file_extension',
    'is_video_file',
    'is_audio_file',
    'ensure_dir_exists',
    
    # Validators
    'is_valid_url',
    'is_valid_video',
    'is_valid_audio',
    'detect_source',
    'validate_file_size',
    'validate_video_duration',
]

__version__ = '1.0.0'


================================================================================
FILE: utils/ffmpeg_helper.py
================================================================================

"""
FFmpeg Helper - Utility functions for FFmpeg operations
Provides wrappers for common FFmpeg tasks
"""

import os
import subprocess
import json
from pathlib import Path
from typing import Dict, Optional, Tuple, List
import ffmpeg

import config


class FFmpegHelper:
    """Helper class for FFmpeg operations"""
    
    @staticmethod
    def check_installed() -> bool:
        """
        Check if FFmpeg is installed and accessible
        
        Returns:
            True if FFmpeg is installed, False otherwise
        """
        try:
            result = subprocess.run(
                ['ffmpeg', '-version'],
                capture_output=True,
                text=True,
                check=True
            )
            return result.returncode == 0
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False
    
    @staticmethod
    def get_version() -> Optional[str]:
        """
        Get FFmpeg version
        
        Returns:
            Version string or None
        """
        try:
            result = subprocess.run(
                ['ffmpeg', '-version'],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                # Parse version from first line
                first_line = result.stdout.split('\n')[0]
                version = first_line.split(' ')[2] if len(first_line.split(' ')) > 2 else 'unknown'
                return version
            
            return None
        except Exception:
            return None
    
    @staticmethod
    def probe_file(file_path: str) -> Optional[Dict]:
        """
        Probe media file using ffprobe
        
        Args:
            file_path: Path to media file
            
        Returns:
            Dict with file information or None
        """
        try:
            if not os.path.exists(file_path):
                return None
            
            probe = ffmpeg.probe(file_path)
            return probe
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error probing file: {str(e)}")
            return None
    
    @staticmethod
    def get_video_info(video_path: str) -> Optional[Dict]:
        """
        Get detailed video information
        
        Args:
            video_path: Path to video file
            
        Returns:
            Dict with video info or None
        """
        try:
            probe = FFmpegHelper.probe_file(video_path)
            
            if not probe:
                return None
            
            # Find video stream
            video_stream = next(
                (stream for stream in probe['streams'] if stream['codec_type'] == 'video'),
                None
            )
            
            # Find audio stream
            audio_stream = next(
                (stream for stream in probe['streams'] if stream['codec_type'] == 'audio'),
                None
            )
            
            if not video_stream:
                return None
            
            # Extract video info
            width = int(video_stream.get('width', 0))
            height = int(video_stream.get('height', 0))
            
            # Get fps
            fps_str = video_stream.get('r_frame_rate', '30/1')
            fps_parts = fps_str.split('/')
            fps = int(fps_parts[0]) / int(fps_parts[1]) if len(fps_parts) == 2 else 30.0
            
            # Get duration
            duration = float(probe['format'].get('duration', 0))
            
            # Get codecs
            video_codec = video_stream.get('codec_name', 'unknown')
            audio_codec = audio_stream.get('codec_name', 'none') if audio_stream else 'none'
            
            # Get bitrates
            video_bitrate = video_stream.get('bit_rate', '0')
            audio_bitrate = audio_stream.get('bit_rate', '0') if audio_stream else '0'
            
            # Get file size
            file_size = int(probe['format'].get('size', 0))
            
            return {
                'width': width,
                'height': height,
                'fps': fps,
                'duration': duration,
                'video_codec': video_codec,
                'audio_codec': audio_codec,
                'video_bitrate': video_bitrate,
                'audio_bitrate': audio_bitrate,
                'file_size': file_size,
                'aspect_ratio': width / height if height > 0 else 0,
                'has_audio': audio_stream is not None,
            }
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error getting video info: {str(e)}")
            return None
    
    @staticmethod
    def get_audio_info(audio_path: str) -> Optional[Dict]:
        """
        Get detailed audio information
        
        Args:
            audio_path: Path to audio file
            
        Returns:
            Dict with audio info or None
        """
        try:
            probe = FFmpegHelper.probe_file(audio_path)
            
            if not probe:
                return None
            
            # Find audio stream
            audio_stream = next(
                (stream for stream in probe['streams'] if stream['codec_type'] == 'audio'),
                None
            )
            
            if not audio_stream:
                return None
            
            # Extract audio info
            duration = float(probe['format'].get('duration', 0))
            codec = audio_stream.get('codec_name', 'unknown')
            bitrate = audio_stream.get('bit_rate', '0')
            sample_rate = int(audio_stream.get('sample_rate', 0))
            channels = int(audio_stream.get('channels', 0))
            
            return {
                'duration': duration,
                'codec': codec,
                'bitrate': bitrate,
                'sample_rate': sample_rate,
                'channels': channels,
                'file_size': int(probe['format'].get('size', 0)),
            }
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error getting audio info: {str(e)}")
            return None
    
    @staticmethod
    def get_video_duration(video_path: str) -> float:
        """
        Get video duration in seconds
        
        Args:
            video_path: Path to video file
            
        Returns:
            Duration in seconds, 0.0 if error
        """
        try:
            info = FFmpegHelper.get_video_info(video_path)
            return info['duration'] if info else 0.0
        except Exception:
            return 0.0
    
    @staticmethod
    def get_audio_duration(audio_path: str) -> float:
        """
        Get audio duration in seconds
        
        Args:
            audio_path: Path to audio file
            
        Returns:
            Duration in seconds, 0.0 if error
        """
        try:
            info = FFmpegHelper.get_audio_info(audio_path)
            return info['duration'] if info else 0.0
        except Exception:
            return 0.0
    
    @staticmethod
    def get_video_resolution(video_path: str) -> Optional[Tuple[int, int]]:
        """
        Get video resolution
        
        Args:
            video_path: Path to video file
            
        Returns:
            Tuple of (width, height) or None
        """
        try:
            info = FFmpegHelper.get_video_info(video_path)
            return (info['width'], info['height']) if info else None
        except Exception:
            return None
    
    @staticmethod
    def get_video_fps(video_path: str) -> Optional[float]:
        """
        Get video FPS
        
        Args:
            video_path: Path to video file
            
        Returns:
            FPS value or None
        """
        try:
            info = FFmpegHelper.get_video_info(video_path)
            return info['fps'] if info else None
        except Exception:
            return None
    
    @staticmethod
    def get_video_codec(video_path: str) -> Optional[str]:
        """
        Get video codec
        
        Args:
            video_path: Path to video file
            
        Returns:
            Codec name or None
        """
        try:
            info = FFmpegHelper.get_video_info(video_path)
            return info['video_codec'] if info else None
        except Exception:
            return None
    
    @staticmethod
    def extract_audio_from_video(
        video_path: str,
        output_path: Optional[str] = None,
        audio_format: str = 'm4a'
    ) -> Optional[str]:
        """
        Extract audio track from video
        
        Args:
            video_path: Path to video file
            output_path: Output audio file path (optional)
            audio_format: Audio format (m4a, mp3, wav, etc.)
            
        Returns:
            Path to extracted audio or None
        """
        try:
            if not os.path.exists(video_path):
                return None
            
            # Generate output path if not provided
            if output_path is None:
                video_name = Path(video_path).stem
                output_path = str(config.TEMP_DIR / f"{video_name}_audio.{audio_format}")
            
            # Extract audio
            cmd = [
                'ffmpeg',
                '-i', video_path,
                '-vn',  # No video
                '-acodec', 'copy' if audio_format == 'm4a' else config.AUDIO_CODEC,
                '-y',
                output_path
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0 and os.path.exists(output_path):
                return output_path
            
            return None
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error extracting audio: {str(e)}")
            return None
    
    @staticmethod
    def convert_video_format(
        input_path: str,
        output_path: str,
        output_format: str = 'mp4',
        video_codec: str = None,
        audio_codec: str = None
    ) -> bool:
        """
        Convert video to different format
        
        Args:
            input_path: Input video path
            output_path: Output video path
            output_format: Output format (mp4, mov, avi, etc.)
            video_codec: Video codec (optional, uses config default)
            audio_codec: Audio codec (optional, uses config default)
            
        Returns:
            True if successful, False otherwise
        """
        try:
            if not os.path.exists(input_path):
                return False
            
            if video_codec is None:
                video_codec = config.VIDEO_CODEC
            
            if audio_codec is None:
                audio_codec = config.AUDIO_CODEC
            
            cmd = [
                'ffmpeg',
                '-i', input_path,
                '-c:v', video_codec,
                '-c:a', audio_codec,
                '-preset', config.VIDEO_PRESET,
                '-crf', str(config.VIDEO_CRF),
                '-y',
                output_path
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            return result.returncode == 0 and os.path.exists(output_path)
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error converting video: {str(e)}")
            return False
    
    @staticmethod
    def create_thumbnail(
        video_path: str,
        output_path: Optional[str] = None,
        time_offset: float = 1.0,
        width: int = 320
    ) -> Optional[str]:
        """
        Create thumbnail from video
        
        Args:
            video_path: Path to video file
            output_path: Output image path (optional)
            time_offset: Time offset in seconds for thumbnail
            width: Thumbnail width in pixels
            
        Returns:
            Path to thumbnail or None
        """
        try:
            if not os.path.exists(video_path):
                return None
            
            if output_path is None:
                video_name = Path(video_path).stem
                output_path = str(config.TEMP_DIR / f"{video_name}_thumb.jpg")
            
            cmd = [
                'ffmpeg',
                '-ss', str(time_offset),
                '-i', video_path,
                '-vframes', '1',
                '-vf', f'scale={width}:-1',
                '-y',
                output_path
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0 and os.path.exists(output_path):
                return output_path
            
            return None
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error creating thumbnail: {str(e)}")
            return None
    
    @staticmethod
    def has_audio_stream(video_path: str) -> bool:
        """
        Check if video has audio stream
        
        Args:
            video_path: Path to video file
            
        Returns:
            True if video has audio, False otherwise
        """
        try:
            info = FFmpegHelper.get_video_info(video_path)
            return info['has_audio'] if info else False
        except Exception:
            return False
    
    @staticmethod
    def get_video_bitrate(video_path: str) -> Optional[str]:
        """
        Get video bitrate
        
        Args:
            video_path: Path to video file
            
        Returns:
            Bitrate string or None
        """
        try:
            info = FFmpegHelper.get_video_info(video_path)
            return info['video_bitrate'] if info else None
        except Exception:
            return None


# Module-level convenience functions
def check_ffmpeg() -> bool:
    """Check if FFmpeg is installed"""
    return FFmpegHelper.check_installed()


def get_video_info(video_path: str) -> Optional[Dict]:
    """Get video information"""
    return FFmpegHelper.get_video_info(video_path)


def get_audio_info(audio_path: str) -> Optional[Dict]:
    """Get audio information"""
    return FFmpegHelper.get_audio_info(audio_path)


def get_video_duration(video_path: str) -> float:
    """Get video duration in seconds"""
    return FFmpegHelper.get_video_duration(video_path)


def get_audio_duration(audio_path: str) -> float:
    """Get audio duration in seconds"""
    return FFmpegHelper.get_audio_duration(audio_path)


def extract_audio_from_video(video_path: str, output_path: Optional[str] = None) -> Optional[str]:
    """Extract audio from video"""
    return FFmpegHelper.extract_audio_from_video(video_path, output_path)


def get_video_resolution(video_path: str) -> Optional[Tuple[int, int]]:
    """Get video resolution"""
    return FFmpegHelper.get_video_resolution(video_path)


def get_video_fps(video_path: str) -> Optional[float]:
    """Get video FPS"""
    return FFmpegHelper.get_video_fps(video_path)


def get_video_codec(video_path: str) -> Optional[str]:
    """Get video codec"""
    return FFmpegHelper.get_video_codec(video_path)


def convert_video_format(input_path: str, output_path: str, output_format: str = 'mp4') -> bool:
    """Convert video format"""
    return FFmpegHelper.convert_video_format(input_path, output_path, output_format)


================================================================================
FILE: utils/file_manager.py
================================================================================

"""
File Manager - Utilities for file operations and temp folder management
Handles file I/O, cleanup, and organization
"""

import os
import shutil
import tempfile
import time
from pathlib import Path
from typing import List, Optional, Dict
from datetime import datetime, timedelta

import config


class FileManager:
    """Manager for file operations and temporary files"""
    
    def __init__(self, base_dir: Optional[Path] = None):
        """
        Initialize file manager
        
        Args:
            base_dir: Base directory for file operations (optional)
        """
        self.base_dir = base_dir or config.PROJECT_ROOT
        self.temp_dir = config.TEMP_DIR
        self.downloads_dir = config.DOWNLOADS_DIR
        self.outputs_dir = config.OUTPUTS_DIR
        
        # Ensure directories exist
        self._ensure_directories()
        
        # Track created files for cleanup
        self.created_files: List[str] = []
        self.created_dirs: List[str] = []
    
    def _ensure_directories(self) -> None:
        """Ensure all required directories exist"""
        for directory in [self.temp_dir, self.downloads_dir, self.outputs_dir]:
            directory.mkdir(parents=True, exist_ok=True)
    
    def create_temp_file(
        self,
        prefix: str = 'temp_',
        suffix: str = '.mp4',
        dir: Optional[Path] = None
    ) -> str:
        """
        Create a temporary file
        
        Args:
            prefix: Filename prefix
            suffix: File extension
            dir: Directory to create file in (optional)
            
        Returns:
            Path to temporary file
        """
        if dir is None:
            dir = self.temp_dir
        
        # Create unique filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"{prefix}{timestamp}{suffix}"
        filepath = dir / filename
        
        # Track for cleanup
        self.created_files.append(str(filepath))
        
        return str(filepath)
    
    def create_temp_dir(
        self,
        prefix: str = 'temp_dir_'
    ) -> str:
        """
        Create a temporary directory
        
        Args:
            prefix: Directory name prefix
            
        Returns:
            Path to temporary directory
        """
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        dirname = f"{prefix}{timestamp}"
        dirpath = self.temp_dir / dirname
        
        dirpath.mkdir(parents=True, exist_ok=True)
        
        # Track for cleanup
        self.created_dirs.append(str(dirpath))
        
        return str(dirpath)
    
    def cleanup_file(self, filepath: str) -> bool:
        """
        Delete a file
        
        Args:
            filepath: Path to file
            
        Returns:
            True if successful, False otherwise
        """
        try:
            if os.path.exists(filepath):
                os.unlink(filepath)
                
                # Remove from tracking
                if filepath in self.created_files:
                    self.created_files.remove(filepath)
                
                return True
            return False
        except Exception as e:
            if config.DEBUG:
                print(f"Error deleting file {filepath}: {str(e)}")
            return False
    
    def cleanup_directory(self, dirpath: str, recursive: bool = True) -> bool:
        """
        Delete a directory
        
        Args:
            dirpath: Path to directory
            recursive: Delete recursively
            
        Returns:
            True if successful, False otherwise
        """
        try:
            if os.path.exists(dirpath):
                if recursive:
                    shutil.rmtree(dirpath)
                else:
                    os.rmdir(dirpath)
                
                # Remove from tracking
                if dirpath in self.created_dirs:
                    self.created_dirs.remove(dirpath)
                
                return True
            return False
        except Exception as e:
            if config.DEBUG:
                print(f"Error deleting directory {dirpath}: {str(e)}")
            return False
    
    def cleanup_all(self) -> None:
        """Clean up all tracked files and directories"""
        # Clean up files
        for filepath in self.created_files[:]:
            self.cleanup_file(filepath)
        
        # Clean up directories
        for dirpath in self.created_dirs[:]:
            self.cleanup_directory(dirpath)
    
    def cleanup_old_files(self, days: int = None) -> int:
        """
        Clean up old temporary files
        
        Args:
            days: Delete files older than this many days (uses config default if None)
            
        Returns:
            Number of files deleted
        """
        if days is None:
            days = config.CLEANUP_AFTER_DAYS
        
        if not config.AUTO_CLEANUP:
            return 0
        
        deleted_count = 0
        cutoff_time = time.time() - (days * 24 * 60 * 60)
        
        # Clean up temp directory
        if self.temp_dir.exists():
            for item in self.temp_dir.iterdir():
                try:
                    # Check modification time
                    if item.stat().st_mtime < cutoff_time:
                        if item.is_file():
                            item.unlink()
                            deleted_count += 1
                        elif item.is_dir():
                            shutil.rmtree(item)
                            deleted_count += 1
                except Exception as e:
                    if config.DEBUG:
                        print(f"Error deleting old file {item}: {str(e)}")
        
        return deleted_count
    
    def get_file_size(self, filepath: str) -> int:
        """
        Get file size in bytes
        
        Args:
            filepath: Path to file
            
        Returns:
            File size in bytes, 0 if error
        """
        try:
            return os.path.getsize(filepath)
        except Exception:
            return 0
    
    def get_file_size_mb(self, filepath: str) -> float:
        """
        Get file size in megabytes
        
        Args:
            filepath: Path to file
            
        Returns:
            File size in MB
        """
        size_bytes = self.get_file_size(filepath)
        return size_bytes / (1024 * 1024)
    
    def get_directory_size(self, dirpath: str) -> int:
        """
        Get total size of directory in bytes
        
        Args:
            dirpath: Path to directory
            
        Returns:
            Total size in bytes
        """
        total_size = 0
        
        try:
            for dirpath_iter, dirnames, filenames in os.walk(dirpath):
                for filename in filenames:
                    filepath = os.path.join(dirpath_iter, filename)
                    if os.path.exists(filepath):
                        total_size += os.path.getsize(filepath)
        except Exception as e:
            if config.DEBUG:
                print(f"Error getting directory size: {str(e)}")
        
        return total_size
    
    def move_file(self, src: str, dst: str) -> bool:
        """
        Move file from source to destination
        
        Args:
            src: Source file path
            dst: Destination file path
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Ensure destination directory exists
            Path(dst).parent.mkdir(parents=True, exist_ok=True)
            
            shutil.move(src, dst)
            return True
        except Exception as e:
            if config.DEBUG:
                print(f"Error moving file: {str(e)}")
            return False
    
    def copy_file(self, src: str, dst: str) -> bool:
        """
        Copy file from source to destination
        
        Args:
            src: Source file path
            dst: Destination file path
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Ensure destination directory exists
            Path(dst).parent.mkdir(parents=True, exist_ok=True)
            
            shutil.copy2(src, dst)
            return True
        except Exception as e:
            if config.DEBUG:
                print(f"Error copying file: {str(e)}")
            return False
    
    def list_files(
        self,
        directory: str,
        extensions: Optional[List[str]] = None,
        recursive: bool = False
    ) -> List[str]:
        """
        List files in directory
        
        Args:
            directory: Directory path
            extensions: Filter by extensions (e.g., ['.mp4', '.mov'])
            recursive: Search recursively
            
        Returns:
            List of file paths
        """
        files = []
        
        try:
            dir_path = Path(directory)
            
            if not dir_path.exists():
                return files
            
            if recursive:
                pattern = '**/*'
            else:
                pattern = '*'
            
            for item in dir_path.glob(pattern):
                if item.is_file():
                    if extensions is None or item.suffix.lower() in extensions:
                        files.append(str(item))
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error listing files: {str(e)}")
        
        return files
    
    # ========================================================================
    # NEW: PATH RESOLUTION AND VIDEO FINDING HELPERS
    # ========================================================================
    
    def resolve_path(self, path: str) -> Optional[str]:
        """
        Resolve relative/absolute paths and expand user home directory
        
        Args:
            path: File or folder path (can be relative, absolute, or with ~)
            
        Returns:
            Absolute resolved path or None if invalid
        """
        try:
            # Strip quotes if present (from drag-and-drop)
            path = path.strip().strip('"').strip("'")
            
            # Expand user home directory (~)
            expanded = os.path.expanduser(path)
            
            # Convert to absolute path
            absolute = os.path.abspath(expanded)
            
            # Check if exists
            if os.path.exists(absolute):
                return absolute
            
            # Try relative to project root
            relative_to_root = os.path.join(str(self.base_dir), path)
            if os.path.exists(relative_to_root):
                return os.path.abspath(relative_to_root)
            
            return None
        except Exception as e:
            if config.DEBUG:
                print(f"Error resolving path: {str(e)}")
            return None
    
    def find_videos_in_folder(
        self,
        folder_path: str,
        recursive: bool = False
    ) -> List[str]:
        """
        Find all video files in a folder
        
        Args:
            folder_path: Path to folder
            recursive: Search recursively in subfolders
            
        Returns:
            List of video file paths (sorted)
        """
        videos = self.list_files(
            folder_path,
            extensions=config.VIDEO_EXTENSIONS,
            recursive=recursive
        )
        
        # Sort by name for consistent ordering
        videos.sort()
        
        return videos
    
    def find_audios_in_folder(
        self,
        folder_path: str,
        recursive: bool = False
    ) -> List[str]:
        """
        Find all audio files in a folder
        
        Args:
            folder_path: Path to folder
            recursive: Search recursively in subfolders
            
        Returns:
            List of audio file paths (sorted)
        """
        audios = self.list_files(
            folder_path,
            extensions=config.AUDIO_EXTENSIONS,
            recursive=recursive
        )
        
        # Sort by name
        audios.sort()
        
        return audios
    
    def normalize_path(self, path: str) -> str:
        """
        Normalize path (resolve .., ., etc.)
        
        Args:
            path: Path to normalize
            
        Returns:
            Normalized path
        """
        return os.path.normpath(path)
    
    def is_relative_path(self, path: str) -> bool:
        """
        Check if path is relative
        
        Args:
            path: Path to check
            
        Returns:
            True if relative, False if absolute
        """
        return not os.path.isabs(path)
    
    def make_relative_path(self, path: str, base: Optional[str] = None) -> str:
        """
        Make path relative to base directory
        
        Args:
            path: Absolute path
            base: Base directory (defaults to project root)
            
        Returns:
            Relative path
        """
        if base is None:
            base = str(self.base_dir)
        
        try:
            return os.path.relpath(path, base)
        except ValueError:
            # Can't make relative (different drives on Windows)
            return path
    
    def get_file_extension(self, filepath: str) -> str:
        """
        Get file extension (lowercase, with dot)
        
        Args:
            filepath: Path to file
            
        Returns:
            Extension (e.g., '.mp4')
        """
        return Path(filepath).suffix.lower()
    
    def get_filename(self, filepath: str, with_extension: bool = True) -> str:
        """
        Get filename from path
        
        Args:
            filepath: Path to file
            with_extension: Include extension
            
        Returns:
            Filename
        """
        path_obj = Path(filepath)
        if with_extension:
            return path_obj.name
        else:
            return path_obj.stem
    
    def change_extension(self, filepath: str, new_extension: str) -> str:
        """
        Change file extension
        
        Args:
            filepath: Original file path
            new_extension: New extension (with or without dot)
            
        Returns:
            New file path with changed extension
        """
        if not new_extension.startswith('.'):
            new_extension = '.' + new_extension
        
        path_obj = Path(filepath)
        return str(path_obj.with_suffix(new_extension))
    
    def ensure_unique_path(self, filepath: str) -> str:
        """
        Ensure path is unique by adding numbers if file exists
        
        Args:
            filepath: Desired file path
            
        Returns:
            Unique file path
        """
        if not os.path.exists(filepath):
            return filepath
        
        path_obj = Path(filepath)
        base = path_obj.stem
        ext = path_obj.suffix
        parent = path_obj.parent
        
        counter = 1
        while True:
            new_name = f"{base}_{counter}{ext}"
            new_path = parent / new_name
            
            if not new_path.exists():
                return str(new_path)
            
            counter += 1
    
    def get_disk_space(self) -> Dict[str, float]:
        """
        Get disk space information
        
        Returns:
            Dict with total, used, and free space in GB
        """
        try:
            stat = shutil.disk_usage(self.base_dir)
            
            return {
                'total_gb': stat.total / (1024 ** 3),
                'used_gb': stat.used / (1024 ** 3),
                'free_gb': stat.free / (1024 ** 3),
                'percent_used': (stat.used / stat.total) * 100 if stat.total > 0 else 0,
            }
        except Exception as e:
            if config.DEBUG:
                print(f"Error getting disk space: {str(e)}")
            return {}


# ============================================================================
# MODULE-LEVEL CONVENIENCE FUNCTIONS
# ============================================================================

_global_manager = None


def get_manager() -> FileManager:
    """Get global file manager instance"""
    global _global_manager
    if _global_manager is None:
        _global_manager = FileManager()
    return _global_manager


def create_temp_dir(prefix: str = 'temp_dir_') -> str:
    """Create temporary directory"""
    manager = get_manager()
    return manager.create_temp_dir(prefix)


def cleanup_temp_files() -> None:
    """Clean up all temporary files"""
    manager = get_manager()
    manager.cleanup_all()


def get_file_size(filepath: str) -> int:
    """Get file size in bytes"""
    manager = get_manager()
    return manager.get_file_size(filepath)


def get_file_extension(filepath: str) -> str:
    """Get file extension"""
    return Path(filepath).suffix.lower()


def is_video_file(filepath: str) -> bool:
    """Check if file is a video"""
    ext = get_file_extension(filepath)
    return ext in config.VIDEO_EXTENSIONS


def is_audio_file(filepath: str) -> bool:
    """Check if file is an audio file"""
    ext = get_file_extension(filepath)
    return ext in config.AUDIO_EXTENSIONS


def ensure_dir_exists(dirpath: str) -> None:
    """Ensure directory exists"""
    Path(dirpath).mkdir(parents=True, exist_ok=True)


def cleanup_old_temp_files(days: int = None) -> int:
    """Clean up old temporary files"""
    manager = get_manager()
    return manager.cleanup_old_files(days)


def get_temp_dir() -> Path:
    """Get temporary directory path"""
    return config.TEMP_DIR


def get_downloads_dir() -> Path:
    """Get downloads directory path"""
    return config.DOWNLOADS_DIR


def get_outputs_dir() -> Path:
    """Get outputs directory path"""
    return config.OUTPUTS_DIR


# ============================================================================
# NEW: PATH RESOLUTION FUNCTIONS
# ============================================================================

def resolve_path(path: str) -> Optional[str]:
    """Resolve file path (handles ~, relative paths, etc.)"""
    manager = get_manager()
    return manager.resolve_path(path)


def find_videos_in_folder(folder_path: str, recursive: bool = False) -> List[str]:
    """Find all videos in folder"""
    manager = get_manager()
    return manager.find_videos_in_folder(folder_path, recursive)


def find_audios_in_folder(folder_path: str, recursive: bool = False) -> List[str]:
    """Find all audio files in folder"""
    manager = get_manager()
    return manager.find_audios_in_folder(folder_path, recursive)


def normalize_path(path: str) -> str:
    """Normalize path"""
    manager = get_manager()
    return manager.normalize_path(path)


def get_filename(filepath: str, with_extension: bool = True) -> str:
    """Get filename from path"""
    manager = get_manager()
    return manager.get_filename(filepath, with_extension)


def ensure_unique_path(filepath: str) -> str:
    """Ensure path is unique"""
    manager = get_manager()
    return manager.ensure_unique_path(filepath)


================================================================================
FILE: utils/validators.py
================================================================================

"""
Validators - URL validation, file validation, and source detection
Provides validation functions for URLs, files, and media content
"""

import os
import re
from pathlib import Path
from typing import Optional, List, Tuple
from urllib.parse import urlparse, parse_qs
import validators as validator_lib

import config
from .ffmpeg_helper import get_video_info, get_audio_info


class Validator:
    """Validator for URLs, files, and media content"""
    
    @staticmethod
    def is_valid_url(url: str) -> bool:
        """
        Check if URL is valid
        
        Args:
            url: URL string to validate
            
        Returns:
            True if valid URL, False otherwise
        """
        try:
            # Use validators library
            result = validator_lib.url(url)
            return result is True
        except Exception:
            return False
    
    @staticmethod
    def detect_source(url: str) -> Optional[str]:
        """
        Detect the source platform from URL
        
        Args:
            url: URL to analyze
            
        Returns:
            Source name ('youtube', 'instagram', 'pinterest') or None
        """
        try:
            url_lower = url.lower()
            
            # Check YouTube patterns
            for pattern in config.URL_PATTERNS['youtube']:
                if re.search(pattern, url_lower):
                    return 'youtube'
            
            # Check Instagram patterns
            for pattern in config.URL_PATTERNS['instagram']:
                if re.search(pattern, url_lower):
                    return 'instagram'
            
            # Check Pinterest patterns
            for pattern in config.URL_PATTERNS['pinterest']:
                if re.search(pattern, url_lower):
                    return 'pinterest'
            
            return None
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error detecting source: {str(e)}")
            return None
    
    @staticmethod
    def is_youtube_url(url: str) -> bool:
        """Check if URL is from YouTube"""
        return Validator.detect_source(url) == 'youtube'
    
    @staticmethod
    def is_instagram_url(url: str) -> bool:
        """Check if URL is from Instagram"""
        return Validator.detect_source(url) == 'instagram'
    
    @staticmethod
    def is_pinterest_url(url: str) -> bool:
        """Check if URL is from Pinterest"""
        return Validator.detect_source(url) == 'pinterest'
    
    @staticmethod
    def is_shorts_url(url: str) -> bool:
        """Check if URL is a YouTube Short"""
        return '/shorts/' in url.lower()
    
    @staticmethod
    def is_reel_url(url: str) -> bool:
        """Check if URL is an Instagram Reel"""
        return '/reel/' in url.lower()
    
    @staticmethod
    def extract_video_id(url: str) -> Optional[str]:
        """
        Extract video ID from URL
        
        Args:
            url: Video URL
            
        Returns:
            Video ID or None
        """
        try:
            source = Validator.detect_source(url)
            
            if source == 'youtube':
                # YouTube video ID patterns
                patterns = [
                    r'(?:youtube\.com/watch\?v=|youtu\.be/|youtube\.com/shorts/)([a-zA-Z0-9_-]+)',
                    r'youtube\.com/embed/([a-zA-Z0-9_-]+)',
                ]
                
                for pattern in patterns:
                    match = re.search(pattern, url)
                    if match:
                        return match.group(1)
            
            elif source == 'instagram':
                # Instagram post/reel ID
                match = re.search(r'/(?:p|reel|tv)/([a-zA-Z0-9_-]+)', url)
                if match:
                    return match.group(1)
            
            elif source == 'pinterest':
                # Pinterest pin ID
                match = re.search(r'/pin/(\d+)', url)
                if match:
                    return match.group(1)
            
            return None
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error extracting video ID: {str(e)}")
            return None
    
    # ========================================================================
    # LOCAL PATH VALIDATION
    # ========================================================================
    
    @staticmethod
    def is_valid_path(path: str) -> bool:
        """
        Check if path exists and is accessible
        
        Args:
            path: File or folder path
            
        Returns:
            True if valid path, False otherwise
        """
        try:
            # Expand user home directory and resolve path
            expanded = os.path.expanduser(path)
            resolved = os.path.abspath(expanded)
            
            # Check if exists and is readable
            if not os.path.exists(resolved):
                return False
            
            if not os.access(resolved, os.R_OK):
                return False
            
            return True
        except Exception:
            return False
    
    @staticmethod
    def is_video_folder(folder_path: str) -> Tuple[bool, int]:
        """
        Check if folder contains video files
        
        Args:
            folder_path: Path to folder
            
        Returns:
            Tuple of (has_videos, count)
        """
        try:
            if not os.path.isdir(folder_path):
                return False, 0
            
            video_count = 0
            for item in os.listdir(folder_path):
                item_path = os.path.join(folder_path, item)
                if os.path.isfile(item_path):
                    ext = Path(item_path).suffix.lower()
                    if ext in config.VIDEO_EXTENSIONS:
                        video_count += 1
            
            return video_count > 0, video_count
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error checking video folder: {str(e)}")
            return False, 0
    
    @staticmethod
    def is_image_folder(folder_path: str) -> Tuple[bool, int]:
        """
        Check if folder contains image files
        
        Args:
            folder_path: Path to folder
            
        Returns:
            Tuple of (has_images, count)
        """
        try:
            if not os.path.isdir(folder_path):
                return False, 0
            
            image_count = 0
            for item in os.listdir(folder_path):
                item_path = os.path.join(folder_path, item)
                if os.path.isfile(item_path):
                    ext = Path(item_path).suffix.lower()
                    if ext in config.IMAGE_EXTENSIONS:
                        image_count += 1
            
            return image_count > 0, image_count
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error checking image folder: {str(e)}")
            return False, 0
    
    @staticmethod
    def validate_local_video(filepath: str) -> Tuple[bool, str]:
        """
        Comprehensive validation for local video file
        
        Args:
            filepath: Path to video file
            
        Returns:
            Tuple of (is_valid, message)
        """
        # Check if file exists
        if not os.path.exists(filepath):
            return False, "File does not exist"
        
        # Check if it's a file (not a directory)
        if not os.path.isfile(filepath):
            return False, "Path is not a file"
        
        # Check if readable
        if not os.access(filepath, os.R_OK):
            return False, "File is not readable (permission denied)"
        
        # Check extension
        ext = Path(filepath).suffix.lower()
        if ext not in config.VIDEO_EXTENSIONS:
            return False, f"Unsupported video format: {ext}"
        
        # Validate with FFmpeg (can read video info)
        try:
            info = get_video_info(filepath)
            if not info:
                return False, "Cannot read video file (may be corrupted)"
            
            # Basic sanity checks
            if info.get('duration', 0) <= 0:
                return False, "Invalid video duration"
            
            if info.get('width', 0) <= 0 or info.get('height', 0) <= 0:
                return False, "Invalid video resolution"
        
        except Exception as e:
            return False, f"Error reading video: {str(e)}"
        
        # Check file size
        size_valid, size_msg = Validator.validate_file_size(filepath)
        if not size_valid:
            return False, size_msg
        
        # Check duration
        duration_valid, duration_msg = Validator.validate_video_duration(filepath)
        if not duration_valid:
            return False, duration_msg
        
        return True, "Video is valid"
    
    @staticmethod
    def validate_local_audio(filepath: str) -> Tuple[bool, str]:
        """
        Comprehensive validation for local audio file
        
        Args:
            filepath: Path to audio file
            
        Returns:
            Tuple of (is_valid, message)
        """
        # Check if file exists
        if not os.path.exists(filepath):
            return False, "File does not exist"
        
        # Check if it's a file
        if not os.path.isfile(filepath):
            return False, "Path is not a file"
        
        # Check if readable
        if not os.access(filepath, os.R_OK):
            return False, "File is not readable (permission denied)"
        
        # Check extension
        ext = Path(filepath).suffix.lower()
        if ext not in config.AUDIO_EXTENSIONS:
            return False, f"Unsupported audio format: {ext}"
        
        # Validate with FFmpeg
        try:
            info = get_audio_info(filepath)
            if not info:
                return False, "Cannot read audio file (may be corrupted)"
            
            if info.get('duration', 0) <= 0:
                return False, "Invalid audio duration"
        
        except Exception as e:
            return False, f"Error reading audio: {str(e)}"
        
        # Check file size
        size_valid, size_msg = Validator.validate_file_size(filepath)
        if not size_valid:
            return False, size_msg
        
        return True, "Audio is valid"
    
    @staticmethod
    def validate_local_image(filepath: str) -> Tuple[bool, str]:
        """
        Comprehensive validation for local image file
        
        Args:
            filepath: Path to image file
            
        Returns:
            Tuple of (is_valid, message)
        """
        # Check if file exists
        if not os.path.exists(filepath):
            return False, "File does not exist"
        
        # Check if it's a file
        if not os.path.isfile(filepath):
            return False, "Path is not a file"
        
        # Check if readable
        if not os.access(filepath, os.R_OK):
            return False, "File is not readable (permission denied)"
        
        # Check extension
        ext = Path(filepath).suffix.lower()
        if ext not in config.IMAGE_EXTENSIONS:
            return False, f"Unsupported image format: {ext}"
        
        # Check file size (images shouldn't be too large)
        try:
            file_size_mb = os.path.getsize(filepath) / (1024 * 1024)
            if file_size_mb > 50:  # 50MB limit for images
                return False, f"Image too large: {file_size_mb:.2f}MB (max: 50MB)"
        except Exception as e:
            return False, f"Error checking file size: {str(e)}"
        
        return True, "Image is valid"
    
    # ========================================================================
    # EXISTING FILE VALIDATION (kept as-is)
    # ========================================================================
    
    @staticmethod
    def is_valid_video_file(filepath: str) -> bool:
        """
        Check if file is a valid video
        
        Args:
            filepath: Path to file
            
        Returns:
            True if valid video file, False otherwise
        """
        try:
            # Check if file exists
            if not os.path.exists(filepath):
                return False
            
            # Check extension
            ext = Path(filepath).suffix.lower()
            if ext not in config.VIDEO_EXTENSIONS:
                return False
            
            # Try to get video info
            info = get_video_info(filepath)
            
            # Validate info
            if info and info.get('duration', 0) > 0:
                return True
            
            return False
        
        except Exception:
            return False
    
    @staticmethod
    def is_valid_audio_file(filepath: str) -> bool:
        """
        Check if file is a valid audio file
        
        Args:
            filepath: Path to file
            
        Returns:
            True if valid audio file, False otherwise
        """
        try:
            # Check if file exists
            if not os.path.exists(filepath):
                return False
            
            # Check extension
            ext = Path(filepath).suffix.lower()
            if ext not in config.AUDIO_EXTENSIONS:
                return False
            
            # Try to get audio info
            info = get_audio_info(filepath)
            
            # Validate info
            if info and info.get('duration', 0) > 0:
                return True
            
            return False
        
        except Exception:
            return False
    
    @staticmethod
    def is_valid_image_file(filepath: str) -> bool:
        """
        Check if file is a valid image
        
        Args:
            filepath: Path to file
            
        Returns:
            True if valid image file, False otherwise
        """
        try:
            # Check if file exists
            if not os.path.exists(filepath):
                return False
            
            # Check extension
            ext = Path(filepath).suffix.lower()
            if ext not in config.IMAGE_EXTENSIONS:
                return False
            
            # Check if readable
            if not os.access(filepath, os.R_OK):
                return False
            
            return True
        
        except Exception:
            return False
    
    @staticmethod
    def validate_file_size(filepath: str, max_size_mb: Optional[int] = None) -> Tuple[bool, str]:
        """
        Validate file size
        
        Args:
            filepath: Path to file
            max_size_mb: Maximum allowed size in MB (uses config default if None)
            
        Returns:
            Tuple of (is_valid, message)
        """
        try:
            if not os.path.exists(filepath):
                return False, "File not found"
            
            if max_size_mb is None:
                max_size_mb = config.MAX_FILE_SIZE_MB
            
            file_size_mb = os.path.getsize(filepath) / (1024 * 1024)
            
            if file_size_mb > max_size_mb:
                return False, f"File too large: {file_size_mb:.2f}MB (max: {max_size_mb}MB)"
            
            return True, f"File size OK: {file_size_mb:.2f}MB"
        
        except Exception as e:
            return False, f"Error checking file size: {str(e)}"
    
    @staticmethod
    def validate_video_duration(
        filepath: str,
        min_duration: Optional[float] = None,
        max_duration: Optional[float] = None
    ) -> Tuple[bool, str]:
        """
        Validate video duration
        
        Args:
            filepath: Path to video file
            min_duration: Minimum duration in seconds (uses config default if None)
            max_duration: Maximum duration in seconds (optional)
            
        Returns:
            Tuple of (is_valid, message)
        """
        try:
            if not os.path.exists(filepath):
                return False, "File not found"
            
            info = get_video_info(filepath)
            
            if not info:
                return False, "Could not read video file"
            
            duration = info.get('duration', 0)
            
            if min_duration is None:
                min_duration = config.MIN_VIDEO_DURATION
            
            if duration < min_duration:
                return False, f"Video too short: {duration:.2f}s (min: {min_duration}s)"
            
            if max_duration and duration > max_duration:
                return False, f"Video too long: {duration:.2f}s (max: {max_duration}s)"
            
            return True, f"Duration OK: {duration:.2f}s"
        
        except Exception as e:
            return False, f"Error checking duration: {str(e)}"
    
    @staticmethod
    def validate_video_resolution(
        filepath: str,
        min_width: int = 720,
        min_height: int = 480
    ) -> Tuple[bool, str]:
        """
        Validate video resolution
        
        Args:
            filepath: Path to video file
            min_width: Minimum width in pixels
            min_height: Minimum height in pixels
            
        Returns:
            Tuple of (is_valid, message)
        """
        try:
            if not os.path.exists(filepath):
                return False, "File not found"
            
            info = get_video_info(filepath)
            
            if not info:
                return False, "Could not read video file"
            
            width = info.get('width', 0)
            height = info.get('height', 0)
            
            if width < min_width or height < min_height:
                return False, f"Resolution too low: {width}x{height} (min: {min_width}x{min_height})"
            
            return True, f"Resolution OK: {width}x{height}"
        
        except Exception as e:
            return False, f"Error checking resolution: {str(e)}"
    
    @staticmethod
    def validate_audio_duration(
        filepath: str,
        min_duration: Optional[float] = None,
        max_duration: Optional[float] = None
    ) -> Tuple[bool, str]:
        """
        Validate audio duration
        
        Args:
            filepath: Path to audio file
            min_duration: Minimum duration in seconds
            max_duration: Maximum duration in seconds
            
        Returns:
            Tuple of (is_valid, message)
        """
        try:
            if not os.path.exists(filepath):
                return False, "File not found"
            
            info = get_audio_info(filepath)
            
            if not info:
                return False, "Could not read audio file"
            
            duration = info.get('duration', 0)
            
            if min_duration and duration < min_duration:
                return False, f"Audio too short: {duration:.2f}s (min: {min_duration}s)"
            
            if max_duration and duration > max_duration:
                return False, f"Audio too long: {duration:.2f}s (max: {max_duration}s)"
            
            return True, f"Duration OK: {duration:.2f}s"
        
        except Exception as e:
            return False, f"Error checking audio duration: {str(e)}"
    
    @staticmethod
    def validate_batch_urls(urls: List[str]) -> Tuple[List[str], List[str]]:
        """
        Validate a batch of URLs
        
        Args:
            urls: List of URLs to validate
            
        Returns:
            Tuple of (valid_urls, invalid_urls)
        """
        valid_urls = []
        invalid_urls = []
        
        for url in urls:
            if Validator.is_valid_url(url) and Validator.detect_source(url):
                valid_urls.append(url)
            else:
                invalid_urls.append(url)
        
        return valid_urls, invalid_urls
    
    @staticmethod
    def validate_batch_size(urls: List[str]) -> Tuple[bool, str]:
        """
        Validate batch size
        
        Args:
            urls: List of URLs
            
        Returns:
            Tuple of (is_valid, message)
        """
        count = len(urls)
        max_count = config.MAX_URLS_PER_BATCH
        
        if count == 0:
            return False, "No URLs provided"
        
        if count > max_count:
            return False, f"Too many URLs: {count} (max: {max_count})"
        
        return True, f"Batch size OK: {count} URLs"
    
    @staticmethod
    def get_url_info(url: str) -> Optional[dict]:
        """
        Get information about a URL
        
        Args:
            url: URL to analyze
            
        Returns:
            Dict with URL info or None
        """
        try:
            if not Validator.is_valid_url(url):
                return None
            
            source = Validator.detect_source(url)
            video_id = Validator.extract_video_id(url)
            
            parsed = urlparse(url)
            
            return {
                'url': url,
                'source': source,
                'video_id': video_id,
                'domain': parsed.netloc,
                'path': parsed.path,
                'is_youtube': source == 'youtube',
                'is_instagram': source == 'instagram',
                'is_pinterest': source == 'pinterest',
                'is_shorts': Validator.is_shorts_url(url),
                'is_reel': Validator.is_reel_url(url),
            }
        
        except Exception as e:
            if config.DEBUG:
                print(f"Error getting URL info: {str(e)}")
            return None
    
    @staticmethod
    def check_file_accessibility(filepath: str) -> Tuple[bool, str]:
        """
        Check if file is accessible
        
        Args:
            filepath: Path to file
            
        Returns:
            Tuple of (is_accessible, message)
        """
        try:
            if not os.path.exists(filepath):
                return False, "File does not exist"
            
            if not os.path.isfile(filepath):
                return False, "Path is not a file"
            
            if not os.access(filepath, os.R_OK):
                return False, "File is not readable"
            
            return True, "File is accessible"
        
        except Exception as e:
            return False, f"Error checking file: {str(e)}"


# ============================================================================
# MODULE-LEVEL CONVENIENCE FUNCTIONS
# ============================================================================

def is_valid_url(url: str) -> bool:
    """Check if URL is valid"""
    return Validator.is_valid_url(url)


def detect_source(url: str) -> Optional[str]:
    """Detect source platform from URL"""
    return Validator.detect_source(url)


def is_valid_video(filepath: str) -> bool:
    """Check if file is a valid video"""
    return Validator.is_valid_video_file(filepath)


def is_valid_audio(filepath: str) -> bool:
    """Check if file is a valid audio file"""
    return Validator.is_valid_audio_file(filepath)


def is_valid_image(filepath: str) -> bool:
    """Check if file is a valid image"""
    return Validator.is_valid_image_file(filepath)


def validate_file_size(filepath: str, max_size_mb: Optional[int] = None) -> Tuple[bool, str]:
    """Validate file size"""
    return Validator.validate_file_size(filepath, max_size_mb)


def validate_video_duration(
    filepath: str,
    min_duration: Optional[float] = None,
    max_duration: Optional[float] = None
) -> Tuple[bool, str]:
    """Validate video duration"""
    return Validator.validate_video_duration(filepath, min_duration, max_duration)


def validate_audio_duration(
    filepath: str,
    min_duration: Optional[float] = None,
    max_duration: Optional[float] = None
) -> Tuple[bool, str]:
    """Validate audio duration"""
    return Validator.validate_audio_duration(filepath, min_duration, max_duration)


def is_youtube_url(url: str) -> bool:
    """Check if URL is from YouTube"""
    return Validator.is_youtube_url(url)


def is_instagram_url(url: str) -> bool:
    """Check if URL is from Instagram"""
    return Validator.is_instagram_url(url)


def is_pinterest_url(url: str) -> bool:
    """Check if URL is from Pinterest"""
    return Validator.is_pinterest_url(url)


def is_shorts_url(url: str) -> bool:
    """Check if URL is a YouTube Short"""
    return Validator.is_shorts_url(url)


def is_reel_url(url: str) -> bool:
    """Check if URL is an Instagram Reel"""
    return Validator.is_reel_url(url)


def extract_video_id(url: str) -> Optional[str]:
    """Extract video ID from URL"""
    return Validator.extract_video_id(url)


def get_url_info(url: str) -> Optional[dict]:
    """Get information about a URL"""
    return Validator.get_url_info(url)


def validate_batch_urls(urls: List[str]) -> Tuple[List[str], List[str]]:
    """Validate a batch of URLs, returns (valid, invalid)"""
    return Validator.validate_batch_urls(urls)


def validate_batch_size(urls: List[str]) -> Tuple[bool, str]:
    """Validate batch size"""
    return Validator.validate_batch_size(urls)


def check_file_accessibility(filepath: str) -> Tuple[bool, str]:
    """Check if file is accessible"""
    return Validator.check_file_accessibility(filepath)


def validate_resolution(
    filepath: str,
    min_width: int = 720,
    min_height: int = 480
) -> Tuple[bool, str]:
    """Validate video resolution"""
    return Validator.validate_video_resolution(filepath, min_width, min_height)


# ============================================================================
# LOCAL PATH VALIDATION FUNCTIONS
# ============================================================================

def is_valid_path(path: str) -> bool:
    """Check if path is valid and accessible"""
    return Validator.is_valid_path(path)


def is_video_folder(folder_path: str) -> Tuple[bool, int]:
    """Check if folder contains videos, returns (has_videos, count)"""
    return Validator.is_video_folder(folder_path)


def is_image_folder(folder_path: str) -> Tuple[bool, int]:
    """Check if folder contains images, returns (has_images, count)"""
    return Validator.is_image_folder(folder_path)


def validate_local_video(filepath: str) -> Tuple[bool, str]:
    """Comprehensive validation for local video file"""
    return Validator.validate_local_video(filepath)


def validate_local_audio(filepath: str) -> Tuple[bool, str]:
    """Comprehensive validation for local audio file"""
    return Validator.validate_local_audio(filepath)


def validate_local_image(filepath: str) -> Tuple[bool, str]:
    """Comprehensive validation for local image file"""
    return Validator.validate_local_image(filepath)

